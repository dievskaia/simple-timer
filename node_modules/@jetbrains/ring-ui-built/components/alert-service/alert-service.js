import { createRoot } from 'react-dom/client';
import getUID from '../global/get-uid.js';
import Alert, { ANIMATION_TIME } from '../alert/alert.js';
import { jsx } from 'react/jsx-runtime';
import Alerts from '../alert/container.js';
import 'react';
import 'classnames';
import '@jetbrains/icons/exception';
import '@jetbrains/icons/checkmark';
import '@jetbrains/icons/warning';
import '@jetbrains/icons/close';
import '../icon/icon.js';
import 'util-deprecate';
import '../icon/icon.constants.js';
import '../_helpers/icon-svg.js';
import 'react-compiler-runtime';
import '../global/memoize.js';
import '../loader-inline/loader-inline.js';
import '../global/data-tests.js';
import '../global/dom.js';
import '../button/button.js';
import '@jetbrains/icons/chevron-down';
import '@jetbrains/icons/chevron-12px-down';
import '../link/clickable-link.js';
import '../global/controls-height.js';
import '../global/configuration.js';
import '../_helpers/button.classes.js';
import '../_helpers/theme.js';
import 'react-dom';

const DEFAULT_ALERT_TIMEOUT = 10000; // 10 seconds
/**
 * @name Alert Service
 */
class AlertService {
  defaultTimeout = DEFAULT_ALERT_TIMEOUT;
  // This alerts are stored in inverse order (last shown is first in array)
  showingAlerts = [];
  containerElement = document.createElement('div');
  reactRoot = createRoot(this.containerElement);
  _getShowingAlerts() {
    return [...this.showingAlerts];
  }
  renderAlertContainer(alerts) {
    if (alerts.length === 0) {
      return /*#__PURE__*/jsx("span", {});
    }
    return /*#__PURE__*/jsx(Alerts, {
      children: alerts.map(alert => {
        const {
          message,
          key,
          ...rest
        } = alert;
        return /*#__PURE__*/jsx(Alert, {
          ...rest,
          children: message
        }, key);
      })
    });
  }
  /**
   * Renders alert container into virtual node to skip maintaining container
   */
  renderAlerts() {
    this.reactRoot.render(this.renderAlertContainer(this.showingAlerts));
  }
  findSameAlert(message, type) {
    return this.showingAlerts.filter(it => it.type === type && it.message === message)[0];
  }
  startAlertClosing(alert) {
    alert.isClosing = true;
    this.renderAlerts();
  }
  remove(key) {
    const alertToClose = this.showingAlerts.filter(alert => alert.key === key)[0];
    if (!alertToClose) {
      return;
    }
    this.startAlertClosing(alertToClose);
  }
  removeWithoutAnimation(key) {
    this.showingAlerts = this.showingAlerts.filter(alert => alert.key !== key);
    this.renderAlerts();
  }
  stopShakingWhenAnimationDone(shakingAlert) {
    setTimeout(() => {
      shakingAlert.showWithAnimation = false;
      shakingAlert.isShaking = false;
      this.renderAlerts();
    }, ANIMATION_TIME);
  }
  addAlert(message, type, timeout = this.defaultTimeout, options = {}) {
    const {
      onCloseRequest,
      onClose,
      ...restOptions
    } = options;
    const sameAlert = this.findSameAlert(message, type);
    if (sameAlert) {
      sameAlert.isShaking = true;
      this.renderAlerts();
      this.stopShakingWhenAnimationDone(sameAlert);
      return sameAlert.key;
    }
    const alert = {
      key: getUID('alert-service-'),
      message,
      type,
      timeout,
      isClosing: false,
      onCloseRequest: () => {
        onCloseRequest?.();
        this.startAlertClosing(alert);
      },
      onClose: () => {
        onClose?.();
        this.removeWithoutAnimation(alert.key);
      },
      ...restOptions
    };
    this.showingAlerts = [alert, ...this.showingAlerts];
    this.renderAlerts();
    return alert.key;
  }
  setDefaultTimeout(timeout) {
    this.defaultTimeout = timeout;
  }
  error(message, timeout) {
    return this.addAlert(message, Alert.Type.ERROR, timeout);
  }
  message(message, timeout) {
    return this.addAlert(message, Alert.Type.MESSAGE, timeout);
  }
  warning(message, timeout) {
    return this.addAlert(message, Alert.Type.WARNING, timeout);
  }
  successMessage(message, timeout) {
    return this.addAlert(message, Alert.Type.SUCCESS, timeout);
  }
  loadingMessage(message, timeout) {
    return this.addAlert(message, Alert.Type.LOADING, timeout);
  }
}
const alertService = new AlertService();

export { AlertService, DEFAULT_ALERT_TIMEOUT, alertService as default };
