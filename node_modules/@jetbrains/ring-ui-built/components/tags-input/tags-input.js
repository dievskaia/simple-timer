import { PureComponent } from 'react';
import classNames from 'classnames';
import getEventKey from '../global/get-event-key.js';
import Select from '../select/select.js';
import TagsList from '../tags-list/tags-list.js';
import Caret from '../caret/caret.js';
import memoize from '../global/memoize.js';
import rerenderHOC from '../global/rerender-hoc.js';
import { S as Size, i as inputStyles } from '../_helpers/input.js';
import { ControlsHeightContext } from '../global/controls-height.js';
import getUID from '../global/get-uid.js';
import { ControlLabel } from '../control-label/control-label.js';
import { jsxs, jsx } from 'react/jsx-runtime';
import '@jetbrains/icons/chevron-down';
import '@jetbrains/icons/close-12px';
import 'dequal';
import '../global/data-tests.js';
import '../global/typescript-utils.js';
import '../_helpers/anchor.js';
import 'react-compiler-runtime';
import '../button/button.js';
import '@jetbrains/icons/chevron-12px-down';
import 'util-deprecate';
import '../icon/icon.js';
import '../icon/icon.constants.js';
import '../_helpers/icon-svg.js';
import '../link/clickable-link.js';
import '../_helpers/button.classes.js';
import '../global/configuration.js';
import '../avatar/avatar.js';
import '../global/url.js';
import '../global/dom.js';
import '../avatar/fallback-avatar.js';
import '../avatar/avatar-size.js';
import '../_helpers/avatar-info.js';
import '../popup/popup.js';
import 'react-dom';
import '../global/schedule-raf.js';
import '../shortcuts/shortcuts.js';
import '../shortcuts/core.js';
import 'combokeys';
import '../global/sniffer.js';
import 'sniffr';
import '../tab-trap/tab-trap.js';
import '../popup/position.js';
import '../popup/popup.consts.js';
import '../popup/popup.target.js';
import '../popup/position-css.js';
import '../_helpers/theme.js';
import '../list/list.js';
import 'react-virtualized/dist/es/List';
import 'react-virtualized/dist/es/AutoSizer';
import 'react-virtualized/dist/es/WindowScroller';
import 'react-virtualized/dist/es/CellMeasurer';
import 'memoize-one';
import '../global/create-stateful-context.js';
import '../list/list-item.js';
import '../checkbox/checkbox.js';
import '@jetbrains/icons/checkmark-12px';
import '@jetbrains/icons/remove-12px';
import '../global/compose-refs.js';
import '../control-help/control-help.js';
import '../link/link.js';
import '../_helpers/link.js';
import '../list/consts.js';
import '../list/list.classes.js';
import '../_helpers/list.js';
import '../list/list-custom.js';
import '../list/list-title.js';
import '../list/list-separator.js';
import '../list/list-hint.js';
import '../global/fuzzy-highlight.js';
import '../i18n/i18n-context.js';
import '../i18n/i18n.js';
import '../select/select-popup.js';
import '@jetbrains/icons/search';
import '../loader-inline/loader-inline.js';
import '../shortcuts/shortcuts-hoc.js';
import '../text/text.js';
import '../_helpers/select-filter.js';
import '../tag/tag.js';

var styles = {"outerContainer":"ring-input-outerContainer","container":"ring-input-container","input":"ring-input-input","tagsInput":"ring-tags-input-tagsInput","tagsInputDisabled":"ring-tags-input-tagsInputDisabled","tagsInputFocused":"ring-tags-input-tagsInputFocused","tagsList":"ring-tags-input-tagsList","tagsSelect":"ring-tags-input-tagsSelect"};

function noop() {}
/**
 * @name Tags Input
 */
const POPUP_VERTICAL_SHIFT = 2;
class TagsInput extends PureComponent {
  static defaultProps = {
    dataSource: noop,
    onAddTag: noop,
    onRemoveTag: noop,
    customTagComponent: null,
    maxPopupHeight: 500,
    minPopupWidth: 360,
    canNotBeEmpty: false,
    disabled: false,
    autoOpen: false,
    renderOptimization: true,
    allowAddNewTags: false,
    filter: {
      fn: () => true
    },
    placeholder: 'Select an option',
    size: Size.M
  };
  constructor(props) {
    super(props);
    this.ngModelStateField = TagsInput.ngModelStateField;
  }
  state = {
    tags: [],
    prevTags: null,
    suggestions: [],
    loading: true,
    focused: false,
    query: '',
    activeIndex: 0
  };
  static getDerivedStateFromProps({
    tags
  }, {
    prevTags
  }) {
    const nextState = {
      prevTags: tags
    };
    if (tags && tags !== prevTags) {
      Object.assign(nextState, {
        tags,
        activeIndex: tags?.length
      });
    }
    return nextState;
  }
  componentDidMount() {
    if (this.props.autoOpen && !this.props.disabled) {
      this.focusInput();
      this.loadSuggestions();
      // eslint-disable-next-line no-underscore-dangle
      this.select?._showPopup();
    }
  }
  static ngModelStateField = 'tags';
  ngModelStateField;
  static contextType = ControlsHeightContext;
  id = this.props.id || getUID('ring-tags-list-');
  node;
  nodeRef = node => {
    this.node = node;
  };
  input;
  caret;
  getInputNode() {
    if (!this.input) {
      this.input = this.select?.filter;
      if (this.input) {
        this.caret = new Caret(this.input);
      }
    }
    return this.input;
  }
  setActiveIndex(activeIndex) {
    this.setState({
      activeIndex
    });
  }
  focusInput = () => {
    this.getInputNode()?.focus();
  };
  focus = () => {
    this.focusInput();
  };
  addTag = tag => {
    if (tag === null) {
      return;
    }
    const isUniqueTag = this.state.tags.filter(item => tag.key === item.key).length === 0;
    this.select?.clear();
    this.select?.filterValue('');
    if (isUniqueTag) {
      this.setState(prevState => ({
        tags: prevState.tags.concat([tag])
      }));
      this.props.onAddTag({
        tag
      });
      this.setActiveIndex();
    }
  };
  onRemoveTag(tagToRemove) {
    return Promise.resolve(this.props.onRemoveTag({
      tag: tagToRemove
    })).then(() => {
      const tags = this.state.tags.filter(tag => tag !== tagToRemove);
      if (this.node) {
        this.setState({
          tags
        });
        this.focusInput();
      }
      return tags;
    }, this.focusInput);
  }
  clickHandler = event => {
    if (event.target !== this.node && event.target.parentElement !== this.node) {
      return;
    }
    // eslint-disable-next-line no-underscore-dangle
    this.select?._clickHandler();
  };
  filterExistingTags = suggestions => {
    const tagsMap = new Map(this.state.tags.map(tag => [tag.key, tag]));
    return suggestions.filter(suggestion => !tagsMap.has(suggestion.key));
  };
  loadSuggestions = (query = '') => this.setState({
    loading: true,
    query
  }, async () => {
    try {
      const suggestionsResult = this.props.dataSource({
        query
      });
      const allSuggestions = Array.isArray(suggestionsResult) ? suggestionsResult : await suggestionsResult;
      const suggestions = this.filterExistingTags(allSuggestions);
      if (this.node && query === this.state.query) {
        this.setState({
          suggestions,
          loading: false
        });
      }
    } catch (e) {
      this.setState({
        loading: false
      });
    }
  });
  _focusHandler = () => {
    this.setActiveIndex(null);
    this.setState({
      focused: true
    });
  };
  _blurHandler = () => {
    this.setState({
      focused: false
    });
  };
  selectTag = moveForward => {
    const activeIndex = typeof this.state.activeIndex === 'number' ? this.state.activeIndex : this.state.tags.length + 1;
    let newActiveIndex = activeIndex + (moveForward ? 1 : -1);
    if (newActiveIndex >= this.state.tags.length) {
      newActiveIndex = this.state.tags.length - 1;
    } else if (newActiveIndex < 0) {
      newActiveIndex = 0;
    }
    if (this.state.activeIndex !== newActiveIndex) {
      this.setActiveIndex(newActiveIndex);
    }
  };
  // eslint-disable-next-line complexity
  handleKeyDown = event => {
    const key = getEventKey(event);
    const isInputFocused = () => {
      var _this$getInputNode$ta;
      return event.target instanceof Element && event.target.matches((_this$getInputNode$ta = this.getInputNode()?.tagName) !== null && _this$getInputNode$ta !== void 0 ? _this$getInputNode$ta : '');
    };
    if (key === ' ' && this.props.allowAddNewTags) {
      event.stopPropagation();
      const value = this.getInputNode()?.value;
      if (value) {
        this.handleTagCreation(value);
      }
      return true;
    }
    // eslint-disable-next-line no-underscore-dangle
    if (this.select?._popup?.isVisible()) {
      return true;
    }
    if (key === 'ArrowLeft') {
      if (this.getInputNode() && this.caret && Number(this.caret?.getPosition()) > 0) {
        return true;
      }
      this.selectTag();
      return false;
    }
    if (key === 'ArrowRight' && !isInputFocused()) {
      if (this.state.activeIndex === this.state.tags.length - 1) {
        if (!this.props.disabled) {
          this.getInputNode()?.focus();
          this.setActiveIndex();
        }
      } else {
        this.selectTag(true);
      }
      return false;
    }
    if (!this.props.disabled) {
      if (key === 'Backspace' && !this.getInputNode()?.value) {
        event.preventDefault();
        const tagsLength = this.state.tags.length;
        // eslint-disable-next-line no-underscore-dangle
        this.select?._hidePopup(true); // otherwise confirmation may be overlapped by popup
        this.onRemoveTag(this.state.tags[tagsLength - 1]);
        return false;
      }
      if ((key === 'Delete' || key === 'Backspace') && this.state.activeIndex !== null && this.state.activeIndex !== undefined && this.state.tags[this.state.activeIndex]) {
        this.onRemoveTag(this.state.tags[this.state.activeIndex]).then(() => this.selectTag(true));
        return false;
      }
    }
    return true;
  };
  handleClick = memoize(tag => () => {
    this.setActiveIndex(this.state.tags.indexOf(tag));
  });
  handleRemove = memoize(tag => () => this.onRemoveTag(tag));
  handleTagCreation = label => {
    this.addTag({
      key: label,
      label
    });
  };
  select;
  selectRef = el => {
    this.select = el;
  };
  render() {
    const {
      focused,
      tags,
      activeIndex
    } = this.state;
    const {
      disabled,
      canNotBeEmpty,
      allowAddNewTags,
      filter,
      size,
      labelType,
      height = typeof this.context === 'function' ? this.context() : this.context,
      label
    } = this.props;
    const classes = classNames(styles.tagsInput, [inputStyles[`size${size}`]], [inputStyles[`height${height}`]], {
      [styles.tagsInputDisabled]: disabled,
      [styles.tagsInputFocused]: focused
    }, this.props.className);
    return /*#__PURE__*/jsxs("div", {
      // it transfers focus to input
      role: "presentation",
      className: classes,
      onKeyDown: this.handleKeyDown,
      onClick: this.clickHandler,
      ref: this.nodeRef,
      children: [label && /*#__PURE__*/jsx(ControlLabel, {
        htmlFor: this.id,
        disabled: disabled,
        type: labelType,
        children: label
      }), /*#__PURE__*/jsx(TagsList, {
        tags: tags,
        activeIndex: activeIndex,
        disabled: disabled,
        canNotBeEmpty: canNotBeEmpty,
        handleRemove: this.handleRemove,
        className: styles.tagsList,
        tagClassName: styles.tag,
        handleClick: this.handleClick,
        customTagComponent: this.props.customTagComponent,
        children: /*#__PURE__*/jsx(Select, {
          id: this.id,
          ref: this.selectRef,
          size: Select.Size.AUTO,
          type: Select.Type.INPUT_WITHOUT_CONTROLS,
          inputPlaceholder: this.props.placeholder,
          data: this.state.suggestions,
          className: classNames(styles.tagsSelect),
          onSelect: this.addTag,
          onFocus: this._focusHandler,
          onBlur: this._blurHandler,
          renderOptimization: this.props.renderOptimization,
          add: allowAddNewTags ? {
            prefix: 'Add new tag'
          } : undefined,
          onAdd: allowAddNewTags ? this.handleTagCreation : undefined,
          filter: filter,
          maxHeight: this.props.maxPopupHeight,
          minWidth: this.props.minPopupWidth,
          top: POPUP_VERTICAL_SHIFT,
          loading: this.state.loading,
          onFilter: this.loadSuggestions,
          onBeforeOpen: this.loadSuggestions,
          onKeyDown: this.handleKeyDown,
          disabled: this.props.disabled,
          loadingMessage: this.props.loadingMessage,
          notFoundMessage: this.props.notFoundMessage,
          hint: this.props.hint
        })
      })]
    });
  }
}
const RerenderableTagsInput = rerenderHOC(TagsInput);

export { RerenderableTagsInput, TagsInput as default };
