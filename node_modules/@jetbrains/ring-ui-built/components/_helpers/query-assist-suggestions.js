import List from '../list/list.js';
import { jsx, jsxs } from 'react/jsx-runtime';

var styles = {"queryAssist":"ring-query-assist-queryAssist","error":"ring-query-assist-error","queryAssistDisabled":"ring-query-assist-queryAssistDisabled","huge":"ring-query-assist-huge","actions":"ring-query-assist-actions","input":"ring-query-assist-input","letter-text":"ring-query-assist-letter-text","letterDefault":"ring-query-assist-letterDefault","letter-field-name":"ring-query-assist-letter-field-name","letter-field-value":"ring-query-assist-letter-field-value","letter-operator":"ring-query-assist-letter-operator","letter-error":"ring-query-assist-letter-error","highlight":"ring-query-assist-highlight","service":"ring-query-assist-service","placeholder":"ring-query-assist-placeholder ring-global-resetButton","hugePlaceholder":"ring-query-assist-hugePlaceholder","letter":"ring-query-assist-letter","icon":"ring-query-assist-icon","rightSearchButton":"ring-query-assist-rightSearchButton","clear":"ring-query-assist-clear","withoutGlass":"ring-query-assist-withoutGlass","loaderActive":"ring-query-assist-loaderActive","loaderOnTheRight":"ring-query-assist-loaderOnTheRight","inputRevertOrder":"ring-query-assist-inputRevertOrder"};

const ICON_ID_LENGTH = 44;
class QueryAssistSuggestions {
  /*
   * Pay attention that this method produces not a 100% unique key.
   * Consider to use a unique identifier provided by a server.
   */
  static createKey(suggestion) {
    const {
      description,
      group,
      icon,
      option,
      prefix = '',
      suffix = ''
    } = suggestion;
    return prefix + option + suffix + group + description + (icon ? icon.substring(icon.length - ICON_ID_LENGTH) : '');
  }
  static renderLabel(suggestion) {
    const {
      className,
      matchingStart = 0,
      matchingEnd = 0,
      option,
      prefix = '',
      suffix = ''
    } = suggestion;
    let wrappedOption;
    let before = '';
    let after = '';
    if (matchingStart !== matchingEnd) {
      before = option.substring(0, matchingStart);
      wrappedOption = /*#__PURE__*/jsx("span", {
        className: styles.highlight,
        children: option.substring(matchingStart, matchingEnd)
      });
      after = option.substring(matchingEnd);
    } else {
      wrappedOption = option;
    }
    const wrappedPrefix = prefix && /*#__PURE__*/jsx("span", {
      className: styles.service,
      children: prefix
    });
    const wrappedSuffix = suffix && /*#__PURE__*/jsx("span", {
      className: styles.service,
      children: suffix
    });
    return /*#__PURE__*/jsxs("span", {
      className: className,
      children: [wrappedPrefix, before, wrappedOption, after, wrappedSuffix]
    });
  }
  static renderGroupSeparator(suggestion, prevSuggestion) {
    const {
      group,
      option
    } = suggestion;
    const {
      SEPARATOR
    } = List.ListProps.Type;
    if (prevSuggestion !== group) {
      return {
        key: option + group + SEPARATOR,
        description: group,
        rgItemType: SEPARATOR
      };
    }
    return null;
  }
  static renderList(suggestions, suggestionRenderer) {
    const renderedSuggestions = [];
    suggestions.forEach((suggestion, index, arr) => {
      const prevSuggestionGroup = arr[index - 1] && arr[index - 1].group;
      const groupSeparator = QueryAssistSuggestions.renderGroupSeparator(suggestion, prevSuggestionGroup);
      if (groupSeparator) {
        renderedSuggestions.push(groupSeparator);
      }
      renderedSuggestions.push(suggestionRenderer(suggestion));
    });
    return renderedSuggestions;
  }
}

export { QueryAssistSuggestions as Q, styles as s };
