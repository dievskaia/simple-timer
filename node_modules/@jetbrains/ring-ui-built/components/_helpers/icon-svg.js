import { c } from 'react-compiler-runtime';
import { memo } from 'react';
import classNames from 'classnames';
import memoize from '../global/memoize.js';
import { jsx } from 'react/jsx-runtime';

var styles = {"icon":"ring-icon-icon","glyph":"ring-icon-glyph","compatibilityMode":"ring-icon-compatibilityMode","gray":"ring-icon-gray","hover":"ring-icon-hover","green":"ring-icon-green","magenta":"ring-icon-magenta","red":"ring-icon-red","blue":"ring-icon-blue","white":"ring-icon-white","loading":"ring-icon-loading","icon-loading":"ring-icon-icon-loading"};

function convertReactSVGDOMProperty(str) {
  return str.replace(/[-|:]([a-z])/g, g => g[1].toUpperCase());
}
function serializeAttrs(map) {
  const res = {};
  for (let i = 0; i < map.length; i++) {
    const key = map[i].name;
    let prop = key;
    if (key === 'class') {
      prop = 'className';
    } else if (!key.startsWith('data-')) {
      prop = convertReactSVGDOMProperty(key);
    }
    res[prop] = map[i].value;
  }
  return res;
}
function extractSVGProps(svgNode) {
  const map = svgNode.attributes;
  return map.length > 0 ? serializeAttrs(map) : null;
}
const getSVGFromSource = memoize(src => {
  const svgContainer = document.createElement('div');
  svgContainer.innerHTML = src;
  const svg = svgContainer.firstElementChild;
  if (svg.remove) {
    svg.remove();
  } else {
    svgContainer.removeChild(svg);
  }
  return {
    props: extractSVGProps(svg),
    html: svg.innerHTML
  };
});
function isCompatibilityMode(iconSrc) {
  const hasWidth = /width=".+"/gi.test(iconSrc);
  const hasHeight = /height=".+"/gi.test(iconSrc);
  return !hasWidth || !hasHeight;
}
function IconSVG(t0) {
  const $ = c(17);
  if ($[0] !== "589684e7b2c66c1a9d7d75c160f4be9d89cef892961d29196549a421758ee7d6") {
    for (let $i = 0; $i < 17; $i += 1) {
      $[$i] = Symbol.for("react.memo_cache_sentinel");
    }
    $[0] = "589684e7b2c66c1a9d7d75c160f4be9d89cef892961d29196549a421758ee7d6";
  }
  let className;
  let rest;
  let src;
  if ($[1] !== t0) {
    ({
      src,
      className,
      ...rest
    } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = rest;
    $[4] = src;
  } else {
    className = $[2];
    rest = $[3];
    src = $[4];
  }
  let t1;
  if ($[5] !== className || $[6] !== src) {
    t1 = classNames(styles.glyph, {
      [styles.compatibilityMode]: isCompatibilityMode(src)
    }, className);
    $[5] = className;
    $[6] = src;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const glyphClasses = t1;
  let t2;
  if ($[8] !== src) {
    t2 = getSVGFromSource(src);
    $[8] = src;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  const {
    props,
    html
  } = t2;
  let t3;
  if ($[10] !== html) {
    t3 = {
      __html: html
    };
    $[10] = html;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  let t4;
  if ($[12] !== glyphClasses || $[13] !== props || $[14] !== rest || $[15] !== t3) {
    t4 = /*#__PURE__*/jsx("svg", {
      ...props,
      ...rest,
      className: glyphClasses,
      dangerouslySetInnerHTML: t3
    });
    $[12] = glyphClasses;
    $[13] = props;
    $[14] = rest;
    $[15] = t3;
    $[16] = t4;
  } else {
    t4 = $[16];
  }
  return t4;
}
var IconSVG$1 = /*#__PURE__*/memo(IconSVG);

export { IconSVG$1 as I, styles as s };
