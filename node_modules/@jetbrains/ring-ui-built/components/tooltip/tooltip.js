import { Component, createContext } from 'react';
import classNames from 'classnames';
import Popup from '../popup/popup.js';
import { Listeners } from '../global/dom.js';
import joinDataTestAttributes from '../global/data-tests.js';
import scheduleRAF from '../global/schedule-raf.js';
import { T as Theme, a as ThemeProvider } from '../_helpers/theme.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import 'react-dom';
import '../global/get-uid.js';
import '../shortcuts/shortcuts.js';
import '../shortcuts/core.js';
import 'combokeys';
import '../global/sniffer.js';
import 'sniffr';
import '../tab-trap/tab-trap.js';
import 'react-compiler-runtime';
import '../global/configuration.js';
import '../popup/position.js';
import '../popup/popup.consts.js';
import '../popup/popup.target.js';
import '../popup/position-css.js';

var styles = {"tooltip":"ring-tooltip-tooltip","inheritedTheme":"ring-tooltip-inheritedTheme","long":"ring-tooltip-long"};

const scheduleScroll = scheduleRAF();
const TooltipContext = /*#__PURE__*/createContext(undefined);
/**
 * @name Tooltip
 */
class Tooltip extends Component {
  static defaultProps = {
    title: '',
    selfOverflowOnly: false,
    theme: Theme.DARK,
    popupProps: {}
  };
  state = {
    showPopup: false,
    showNestedPopup: false
  };
  componentDidMount() {
    if (this.props.title) {
      this.addListeners();
    }
  }
  componentDidUpdate(prevProps) {
    if (!prevProps.title && this.props.title) {
      this.addListeners();
    } else if (prevProps.title && !this.props.title) {
      this.hidePopup();
      this.listeners.removeAll();
    }
  }
  componentWillUnmount() {
    clearTimeout(this.timeout);
    this.listeners.removeAll();
  }
  static PopupProps = Popup.PopupProps;
  static contextType = TooltipContext;
  timeout;
  listeners = new Listeners();
  containerNode;
  containerRef = el => {
    this.containerNode = el;
  };
  tryToShowPopup = () => {
    const {
      delay,
      title
    } = this.props;
    if (!title) {
      return;
    }
    if (delay) {
      clearTimeout(this.timeout);
      this.timeout = window.setTimeout(this.showPopup, delay);
    } else {
      this.showPopup();
    }
  };
  showPopup = () => {
    if (this.props.selfOverflowOnly) {
      const {
        containerNode
      } = this;
      // rare cases when containerNode is null are possible;
      // probably the collision is due to the asynchronous nature of the code,
      // i.e. this code runs after the component is unmounted,
      // although at first glance it looks unlikely.
      if (!containerNode) {
        return;
      }
      // inline element?
      if (containerNode.clientWidth === 0 && containerNode.clientHeight === 0) {
        return;
      }
      if (containerNode.scrollWidth <= containerNode.clientWidth && containerNode.scrollHeight <= containerNode.clientHeight) {
        return;
      }
    }
    this.context?.onNestedTooltipShow();
    this.setState({
      showPopup: true
    });
  };
  hidePopup = () => {
    clearTimeout(this.timeout);
    this.context?.onNestedTooltipHide();
    this.setState({
      showPopup: false
    });
  };
  addListeners() {
    if (this.containerNode) {
      this.listeners.add(this.containerNode, 'mouseenter', this.tryToShowPopup);
      this.listeners.add(this.containerNode, 'mouseleave', ev => {
        if (ev.relatedTarget && this.popup?.container?.contains(ev.relatedTarget)) {
          return;
        }
        this.hidePopup();
      });
      this.listeners.add(this.containerNode, 'focusin', this.tryToShowPopup);
      this.listeners.add(this.containerNode, 'focusout', ev => {
        if (ev.relatedTarget && this.popup?.container?.contains(ev.relatedTarget)) {
          return;
        }
        this.hidePopup();
      });
    }
    this.listeners.add(document, 'scroll', () => scheduleScroll(this.hidePopup), {
      passive: true
    });
  }
  hideIfMovedOutsidePopup = ev => {
    if (!('relatedTarget' in ev) || this.popup?.container?.contains(ev.relatedTarget)) {
      return;
    }
    this.hidePopup();
  };
  popup;
  popupRef = el => {
    this.popup = el;
  };
  onNestedTooltipShow = () => {
    this.setState({
      showNestedPopup: true
    });
  };
  onNestedTooltipHide = () => {
    this.setState({
      showNestedPopup: false
    });
  };
  render() {
    const {
      children,
      'data-test': dataTest,
      title,
      delay,
      theme,
      selfOverflowOnly,
      popupProps,
      long,
      ...restProps
    } = this.props;
    const ariaProps = typeof title === 'string' && !!title ? {
      'aria-label': title,
      role: 'tooltip'
    } : {};
    const {
      onNestedTooltipShow,
      onNestedTooltipHide
    } = this;
    const popup = /*#__PURE__*/jsx(Popup, {
      trapFocus: false,
      anchorElement: this.containerNode,
      hidden: !this.state.showPopup || this.state.showNestedPopup,
      onCloseAttempt: this.hidePopup,
      maxHeight: 400,
      attached: false,
      onMouseOut: this.hideIfMovedOutsidePopup,
      top: 4,
      dontCloseOnAnchorClick: true,
      ref: this.popupRef,
      ...popupProps,
      className: classNames(styles.tooltip, {
        [styles.long]: long,
        [styles.inheritedTheme]: theme === 'inherit'
      }, popupProps?.className),
      children: title
    });
    return /*#__PURE__*/jsx(TooltipContext.Provider, {
      value: {
        onNestedTooltipShow,
        onNestedTooltipHide
      },
      children: /*#__PURE__*/jsxs("span", {
        ...ariaProps,
        ...restProps,
        ref: this.containerRef,
        "data-test": joinDataTestAttributes('ring-tooltip', dataTest),
        "data-test-title": typeof title === 'string' ? title : undefined,
        children: [children, theme === 'inherit' ? popup : /*#__PURE__*/jsx(ThemeProvider, {
          theme: theme,
          passToPopups: true,
          WrapperComponent: props => /*#__PURE__*/jsx("span", {
            ...props
          }),
          children: popup
        })]
      })
    });
  }
}

export { Tooltip as default };
