import { Component, createElement } from 'react';
import classNames from 'classnames';
import VirtualizedList from 'react-virtualized/dist/es/List';
import AutoSizer from 'react-virtualized/dist/es/AutoSizer';
import WindowScrollerComponent from 'react-virtualized/dist/es/WindowScroller';
import { CellMeasurerCache, CellMeasurer } from 'react-virtualized/dist/es/CellMeasurer';
import deprecate from 'util-deprecate';
import memoizeOne from 'memoize-one';
import joinDataTestAttributes from '../global/data-tests.js';
import getUID from '../global/get-uid.js';
import scheduleRAF from '../global/schedule-raf.js';
import memoize from '../global/memoize.js';
import { preventDefault } from '../global/dom.js';
import Shortcuts from '../shortcuts/shortcuts.js';
import createStatefulContext from '../global/create-stateful-context.js';
import ListItem from './list-item.js';
import ListCustom from './list-custom.js';
import ListTitle from './list-title.js';
import ListSeparator from './list-separator.js';
import ListHint from './list-hint.js';
import { Type, Dimension, DEFAULT_ITEM_TYPE } from './consts.js';
import { s as styles } from '../_helpers/list.js';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import '../shortcuts/core.js';
import 'combokeys';
import '../global/sniffer.js';
import 'sniffr';
import 'react-compiler-runtime';
import '../avatar/avatar.js';
import '../global/url.js';
import '../avatar/fallback-avatar.js';
import '../avatar/avatar-size.js';
import '../_helpers/avatar-info.js';
import '../checkbox/checkbox.js';
import '@jetbrains/icons/checkmark-12px';
import '@jetbrains/icons/remove-12px';
import '../icon/icon.js';
import '../icon/icon.constants.js';
import '../_helpers/icon-svg.js';
import '../global/compose-refs.js';
import '../control-help/control-help.js';
import '../link/link.js';
import '../link/clickable-link.js';
import '../_helpers/link.js';
import './list.classes.js';
import '../global/get-event-key.js';

function noop() {}
const warnEmptyKey = deprecate(() => {}, 'No key passed for list item with non-string label. It is considered as a bad practice and has been deprecated, please provide a key.');
/**
 * @param {Type} listItemType
 * @param {Object} item list item
 */
function isItemType(listItemType, item) {
  let type = item.rgItemType;
  if (type === null || type === undefined) {
    type = DEFAULT_ITEM_TYPE;
  }
  return type === listItemType;
}
const nonActivatableTypes = [Type.SEPARATOR, Type.TITLE, Type.MARGIN];
function isActivatable(item) {
  return item !== null && item !== undefined && !nonActivatableTypes.includes(item.rgItemType) && !item.disabled;
}
function getDataHash(data) {
  return data.map(it => `${it.key}-${it.disabled}`).join('-');
}
const shouldActivateFirstItem = props => props.activateFirstItem || props.activateSingleItem && props.data.length === 1;
const ActiveItemContext = createStatefulContext(undefined, 'ActiveItem');
/**
 * @name List
 * @constructor
 * @extends {ReactComponent}
 */
/**
 * Displays a list of items.
 */
class List extends Component {
  static defaultProps = {
    data: [],
    restoreActiveIndex: false,
    // restore active item using its "key" property
    activateSingleItem: false,
    // if there is only one item, activate it
    activateFirstItem: false,
    // if there no active items, activate the first one
    onMouseOut: noop,
    onSelect: noop,
    onScrollToBottom: noop,
    onResize: noop,
    shortcuts: false,
    renderOptimization: true,
    disableMoveDownOverflow: false,
    ariaLabel: 'List'
  };
  state = {
    activeIndex: null,
    prevActiveIndex: null,
    prevData: [],
    activeItem: null,
    needScrollToActive: false,
    scrolling: false,
    hasOverflow: false,
    scrolledToBottom: false
  };
  static getDerivedStateFromProps(nextProps, prevState) {
    const {
      prevActiveIndex,
      prevData,
      activeItem
    } = prevState;
    const {
      data,
      activeIndex,
      restoreActiveIndex
    } = nextProps;
    const nextState = {
      prevActiveIndex: activeIndex,
      prevData: data
    };
    if (data !== prevData) {
      // Only clear activeIndex if it's out of bounds OR the item at that position changed
      const currentActiveIndex = prevState.activeIndex;
      const currentActiveItem = prevState.activeItem;
      if (currentActiveIndex !== null && (currentActiveIndex >= data.length || !data[currentActiveIndex] || currentActiveItem && data[currentActiveIndex].key !== currentActiveItem.key)) {
        Object.assign(nextState, {
          activeIndex: null,
          activeItem: null
        });
      }
    }
    if (activeIndex !== null && activeIndex !== undefined && activeIndex !== prevActiveIndex && data[activeIndex]) {
      Object.assign(nextState, {
        activeIndex,
        activeItem: data[activeIndex],
        needScrollToActive: true
      });
    } else if (data !== prevData && restoreActiveIndex && activeItem && activeItem.key) {
      // Restore active index if there is an item with the same "key" property
      const index = data.findIndex(item => item.key === activeItem.key);
      if (index >= 0) {
        Object.assign(nextState, {
          activeIndex: index,
          activeItem: data[index]
        });
      }
    }
    return nextState;
  }
  componentDidMount() {
    if ((this.props.activeIndex === null || this.props.activeIndex === undefined) && shouldActivateFirstItem(this.props)) {
      this.activateFirst();
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    return Object.keys(nextProps).some(key => !Object.is(nextProps[key], this.props[key])) || Object.keys(nextState).some(key => nextState[key] !== this.state[key]);
  }
  componentDidUpdate(prevProps) {
    if (this.virtualizedList && prevProps.data !== this.props.data) {
      this.virtualizedList.recomputeRowHeights();
    }
    const {
      activeIndex
    } = this.state;
    const isActiveItemRetainedPosition = activeIndex ? prevProps.data[activeIndex]?.key === this.props.data[activeIndex]?.key : false;
    if ((this.props.activeIndex === null || this.props.activeIndex === undefined) && getDataHash(this.props.data) !== getDataHash(prevProps.data) && shouldActivateFirstItem(this.props) && !isActiveItemRetainedPosition) {
      this.activateFirst();
    }
    this.checkOverflow();
  }
  componentWillUnmount() {
    this.unmounted = true;
  }
  scheduleScrollListener = scheduleRAF();
  static isItemType = isItemType;
  static ListHint = ListHint;
  static ListProps = {
    Type,
    Dimension
  };
  virtualizedList;
  unmounted;
  container;
  // eslint-disable-next-line no-magic-numbers
  _bufferSize = 10; // keep X items above and below of the visible area
  // reuse size cache for similar items
  sizeCacheKey = index => {
    if (index === 0 || index === this.props.data.length + 1) {
      return Type.MARGIN;
    }
    const item = this.props.data[index - 1];
    const isFirst = index === 1;
    switch (item.rgItemType) {
      case Type.SEPARATOR:
      case Type.TITLE:
        return `${item.rgItemType}${isFirst ? '_first' : ''}${item.description ? '_desc' : ''}`;
      case Type.MARGIN:
        return Type.MARGIN;
      case Type.CUSTOM:
        return `${Type.CUSTOM}_${item.key}`;
      case Type.ITEM:
      case Type.LINK:
      default:
        if (item.details) {
          return `${Type.ITEM}_${item.details}`;
        }
        return Type.ITEM;
    }
  };
  _cache = new CellMeasurerCache({
    defaultHeight: this.defaultItemHeight(),
    fixedWidth: true,
    keyMapper: this.sizeCacheKey
  });
  _hasActivatableItems = memoizeOne(items => items.some(isActivatable));
  hasActivatableItems() {
    return this._hasActivatableItems(this.props.data);
  }
  activateFirst = () => {
    const firstActivatableIndex = this.props.data.findIndex(isActivatable);
    if (firstActivatableIndex >= 0) {
      this.setState({
        activeIndex: firstActivatableIndex,
        activeItem: this.props.data[firstActivatableIndex],
        needScrollToActive: true
      });
    }
  };
  selectHandler = memoize(index => (event, tryKeepOpen = false) => {
    const item = this.props.data[index];
    if (!this.props.useMouseUp && item.onClick) {
      item.onClick(item, event);
    } else if (this.props.useMouseUp && item.onMouseUp) {
      item.onMouseUp(item, event);
    }
    if (this.props.onSelect) {
      this.props.onSelect(item, event, {
        tryKeepOpen
      });
    }
  });
  checkboxHandler = memoize(index => event => this.selectHandler(index)(event, true));
  upHandler = e => {
    const {
      data,
      disableMoveOverflow
    } = this.props;
    const index = this.state.activeIndex;
    let newIndex;
    if (index === null || index === 0) {
      if (!disableMoveOverflow) {
        newIndex = data.length - 1;
      } else {
        return;
      }
    } else {
      newIndex = index - 1;
    }
    this.moveHandler(newIndex, this.upHandler, e);
  };
  downHandler = e => {
    const {
      data,
      disableMoveOverflow,
      disableMoveDownOverflow
    } = this.props;
    const index = this.state.activeIndex;
    let newIndex;
    if (index === null) {
      newIndex = 0;
    } else if (index + 1 === data.length) {
      if (!disableMoveOverflow && !disableMoveDownOverflow) {
        newIndex = 0;
      } else {
        return;
      }
    } else {
      newIndex = index + 1;
    }
    this.moveHandler(newIndex, this.downHandler, e);
  };
  homeHandler = e => {
    this.moveHandler(0, this.downHandler, e);
  };
  endHandler = e => {
    this.moveHandler(this.props.data.length - 1, this.upHandler, e);
  };
  moveHandler(index, retryCallback, e) {
    let correctedIndex;
    if (this.props.data.length === 0 || !this.hasActivatableItems()) {
      return;
    }
    if (this.props.data.length < index) {
      correctedIndex = 0;
    } else {
      correctedIndex = index;
    }
    const item = this.props.data[correctedIndex];
    this.setState({
      activeIndex: correctedIndex,
      activeItem: item,
      needScrollToActive: true
    }, function onSet() {
      if (!isActivatable(item)) {
        retryCallback(e);
        return;
      }
      if (e.key !== 'Home' && e.key !== 'End') {
        preventDefault(e);
      }
    });
  }
  mouseHandler = () => {
    this.setState({
      scrolling: false
    });
  };
  scrollHandler = () => {
    this.setState({
      scrolling: true
    }, this.scrollEndHandler);
  };
  enterHandler = (event, shortcut) => {
    if (this.state.activeIndex !== null) {
      const item = this.props.data[this.state.activeIndex];
      this.selectHandler(this.state.activeIndex)(event);
      if (item.href && !event.defaultPrevented) {
        if (shortcut !== null && shortcut !== undefined && ['command+enter', 'ctrl+enter'].includes(shortcut)) {
          window.open(item.href, '_blank');
        } else if (shortcut === 'shift+enter') {
          window.open(item.href);
        } else {
          window.location.href = item.href;
        }
      }
      return false; // do not propagate event
    }
    return true; // propagate event to the parent component (e.g., QueryAssist)
  };
  getFirst() {
    return this.props.data.find(item => item.rgItemType === Type.ITEM || item.rgItemType === Type.CUSTOM);
  }
  getSelected() {
    return this.state.activeIndex ? this.props.data[this.state.activeIndex] : null;
  }
  defaultItemHeight() {
    return this.props.compact ? Dimension.COMPACT_ITEM_HEIGHT : Dimension.ITEM_HEIGHT;
  }
  scrollEndHandler = () => this.scheduleScrollListener(() => {
    const innerContainer = this.inner;
    if (innerContainer) {
      const maxScrollingPosition = innerContainer.scrollHeight;
      const sensitivity = this.defaultItemHeight() / 2;
      const currentScrollingPosition = innerContainer.scrollTop + innerContainer.clientHeight + sensitivity;
      const scrolledToBottom = maxScrollingPosition > 0 && currentScrollingPosition >= maxScrollingPosition;
      if (!this.unmounted) {
        this.setState({
          scrolledToBottom
        });
      }
      if (scrolledToBottom) {
        this.props.onScrollToBottom();
      }
    }
  });
  checkOverflow = () => {
    if (this.inner) {
      this.setState({
        hasOverflow: this.inner.scrollHeight - this.inner.clientHeight > 1
      });
    }
  };
  getVisibleListHeight(maxHeight) {
    return maxHeight - this.defaultItemHeight() - Dimension.INNER_PADDING;
  }
  _deprecatedGenerateKeyFromContent(itemProps) {
    const identificator = itemProps.label || itemProps.description;
    const isString = typeof identificator === 'string' || identificator instanceof String;
    if (identificator && !isString) {
      warnEmptyKey();
      return `${itemProps.rgItemType}_${JSON.stringify(identificator)}`;
    }
    return `${itemProps.rgItemType}_${identificator}`;
  }
  getId(item) {
    return item !== null && item !== undefined ? `${this.id}:${item.key || this._deprecatedGenerateKeyFromContent(item)}` : undefined;
  }
  // eslint-disable-next-line complexity
  renderItem = ({
    index = 1,
    style,
    isScrolling = false,
    parent,
    key
  }) => {
    let itemKey;
    let el;
    const realIndex = index - 1;
    const item = this.props.data[realIndex];
    const itemId = this.getId(item);
    const isActive = realIndex === this.state.activeIndex;
    // top and bottom margins
    if (index === 0 || index === this.props.data.length + 1 || item.rgItemType === Type.MARGIN) {
      itemKey = key || `${Type.MARGIN}_${index}`;
      el = /*#__PURE__*/jsx("div", {
        style: {
          height: Dimension.MARGIN
        }
      });
    } else {
      // Hack around SelectNG implementation
      const {
        selectedLabel,
        originalModel,
        ...restProps
      } = item;
      const cleanedProps = restProps;
      if (cleanedProps.url) {
        cleanedProps.href = cleanedProps.url;
      }
      if (cleanedProps.href) {
        cleanedProps.rgItemType = Type.LINK;
      }
      cleanedProps.description = typeof cleanedProps.description === 'string' ? cleanedProps.description.trim() : cleanedProps.description;
      const itemProps = Object.assign({
        rgItemType: DEFAULT_ITEM_TYPE
      }, restProps);
      itemKey = key || itemId;
      itemProps.hover = isActive;
      if (itemProps.hoverClassName !== null && itemProps.hoverClassName !== undefined && itemProps.hover) {
        itemProps.className = classNames(itemProps.className, itemProps.hoverClassName);
      }
      itemProps.tabIndex = -1;
      itemProps.scrolling = isScrolling;
      const selectHandler = this.selectHandler(realIndex);
      if (this.props.useMouseUp) {
        itemProps.onMouseUp = selectHandler;
      } else {
        itemProps.onClick = selectHandler;
      }
      itemProps.onCheckboxChange = this.checkboxHandler(realIndex);
      if (itemProps.compact === null || itemProps.compact === undefined) {
        itemProps.compact = this.props.compact;
      }
      // Add global className props for sub-elements
      itemProps.itemClassName = this.props.itemClassName;
      itemProps.labelClassName = this.props.labelClassName;
      itemProps.descriptionClassName = this.props.descriptionClassName;
      itemProps.detailsClassName = this.props.detailsClassName;
      let ItemComponent;
      const isFirst = index === 1;
      switch (itemProps.rgItemType) {
        case Type.SEPARATOR:
          ItemComponent = ListSeparator;
          itemProps.isFirst = isFirst;
          break;
        case Type.LINK:
        case Type.ITEM:
          ItemComponent = ListItem;
          this.addItemDataTestToProp(itemProps);
          break;
        case Type.CUSTOM:
          ItemComponent = ListCustom;
          this.addItemDataTestToProp(itemProps);
          break;
        case Type.TITLE:
          itemProps.isFirst = isFirst;
          ItemComponent = ListTitle;
          break;
        default:
          throw new Error(`Unknown menu element type: ${itemProps.rgItemType}`);
      }
      el = /*#__PURE__*/createElement(ItemComponent, {
        ...itemProps,
        key: itemProps.key
      });
    }
    return parent ? /*#__PURE__*/jsx(CellMeasurer, {
      cache: this._cache,
      parent: parent,
      rowIndex: index,
      columnIndex: 0,
      children: ({
        registerChild
      }) => /*#__PURE__*/jsx("div", {
        ref: registerChild,
        style: style,
        role: "row",
        "aria-selected": isActive,
        id: itemId,
        children: /*#__PURE__*/jsx("div", {
          role: "cell",
          children: el
        })
      })
    }, itemKey) : /*#__PURE__*/jsx("div", {
      role: "row",
      "aria-selected": isActive,
      id: itemId,
      children: /*#__PURE__*/jsx("div", {
        role: "cell",
        children: el
      })
    }, itemKey);
  };
  addItemDataTestToProp = props => {
    props['data-test'] = joinDataTestAttributes('ring-list-item', props['data-test']);
    return props;
  };
  virtualizedListRef = el => {
    this.virtualizedList = el;
  };
  containerRef = el => {
    this.container = el;
  };
  _inner;
  get inner() {
    if (!this._inner) {
      this._inner = this.container && this.container.querySelector('.ring-list__i');
    }
    return this._inner;
  }
  renderVirtualizedInner({
    height,
    maxHeight,
    autoHeight = false,
    rowCount,
    isScrolling,
    onChildScroll = noop,
    scrollTop,
    registerChild
  }) {
    const dirOverride = {
      direction: 'inherit'
    }; // Virtualized sets "direction: ltr" by default https://github.com/bvaughn/react-virtualized/issues/457
    return /*#__PURE__*/jsx(AutoSizer, {
      disableHeight: true,
      onResize: this.props.onResize,
      children: ({
        width
      }) => /*#__PURE__*/jsx("div", {
        ref: registerChild,
        children: /*#__PURE__*/jsx(VirtualizedList, {
          "aria-label": this.props.ariaLabel,
          ref: this.virtualizedListRef,
          className: classNames('ring-list__i', {
            [styles.overscrollNone]: this.props.preventListOverscroll
          }),
          autoHeight: autoHeight,
          style: maxHeight ? {
            maxHeight,
            height: 'auto',
            ...dirOverride
          } : dirOverride,
          autoContainerWidth: true,
          height: height,
          width: width,
          isScrolling: isScrolling,
          onScroll: e => {
            onChildScroll(e);
            this.scrollEndHandler();
          },
          scrollTop: scrollTop,
          rowCount: rowCount,
          estimatedRowSize: this.defaultItemHeight(),
          rowHeight: this._cache.rowHeight,
          rowRenderer: this.renderItem,
          overscanRowCount: this._bufferSize
          // ensure rerendering
          ,
          noop: () => {},
          scrollToIndex: !this.props.disableScrollToActive && this.state.needScrollToActive && this.state.activeIndex !== null && this.state.activeIndex !== undefined ? this.state.activeIndex + 1 : undefined,
          scrollToAlignment: "center",
          deferredMeasurementCache: this._cache,
          onRowsRendered: this.checkOverflow,
          containerRole: "none" // row role is set by rowRenderer
        })
      })
    });
  }
  renderVirtualized(maxHeight, rowCount) {
    if (maxHeight) {
      return this.renderVirtualizedInner({
        height: maxHeight,
        maxHeight,
        rowCount
      });
    }
    return /*#__PURE__*/jsx(WindowScrollerComponent, {
      children: props => this.renderVirtualizedInner({
        ...props,
        rowCount,
        autoHeight: true
      })
    });
  }
  renderSimple(maxHeight, rowCount) {
    const items = [];
    for (let index = 0; index < rowCount; index++) {
      items.push(this.renderItem({
        index,
        isScrolling: this.state.scrolling
      }));
    }
    return /*#__PURE__*/jsx("div", {
      className: classNames('ring-list__i', styles.simpleInner),
      onScroll: this.scrollHandler,
      onMouseMove: this.mouseHandler,
      children: /*#__PURE__*/jsx("div", {
        "aria-label": this.props.ariaLabel,
        role: "grid",
        style: maxHeight ? {
          maxHeight: this.getVisibleListHeight(maxHeight)
        } : undefined,
        children: items
      })
    });
  }
  id = getUID('list-');
  shortcutsScope = this.id;
  shortcutsMap = {
    up: this.upHandler,
    down: this.downHandler,
    home: this.homeHandler,
    end: this.endHandler,
    enter: this.enterHandler,
    'meta+enter': this.enterHandler,
    'ctrl+enter': this.enterHandler,
    'command+enter': this.enterHandler,
    'shift+enter': this.enterHandler
  };
  /** @override */
  render() {
    const hint = this.getSelected() && this.props.hintOnSelection || this.props.hint;
    const fadeStyles = hint ? {
      bottom: Dimension.ITEM_HEIGHT
    } : undefined;
    const rowCount = this.props.data.length + 2;
    const maxHeight = this.props.maxHeight && this.getVisibleListHeight(this.props.maxHeight);
    const classes = classNames(styles.list, this.props.className);
    return /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(ActiveItemContext.Updater, {
        value: this.getId(this.state.activeItem),
        skipUpdate: this.props.hidden || !isActivatable(this.state.activeItem)
      }), /*#__PURE__*/jsxs("div", {
        id: this.props.id,
        ref: this.containerRef,
        className: classes,
        onMouseOut: this.props.onMouseOut,
        onBlur: this.props.onMouseOut,
        "data-test": "ring-list",
        children: [this.props.shortcuts && /*#__PURE__*/jsx(Shortcuts, {
          map: this.props.shortcutsMap ? {
            ...this.shortcutsMap,
            ...this.props.shortcutsMap
          } : this.shortcutsMap,
          scope: this.shortcutsScope
        }), this.props.renderOptimization ? this.renderVirtualized(maxHeight, rowCount) : this.renderSimple(maxHeight, rowCount), this.state.hasOverflow && !this.state.scrolledToBottom && /*#__PURE__*/jsx("div", {
          className: styles.fade,
          style: fadeStyles
        }), hint && /*#__PURE__*/jsx(ListHint, {
          label: hint
        })]
      })]
    });
  }
}

export { ActiveItemContext, List as default };
