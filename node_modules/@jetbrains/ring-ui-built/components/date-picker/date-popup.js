import * as React from 'react';
import { Component, createElement } from 'react';
import { isAfter } from 'date-fns/isAfter';
import { isBefore } from 'date-fns/isBefore';
import { isSameDay } from 'date-fns/isSameDay';
import { startOfDay } from 'date-fns/startOfDay';
import { set } from 'date-fns';
import memoize from '../global/memoize.js';
import DateInput from './date-input.js';
import Months from './months.js';
import Years from './years.js';
import Weekdays from './weekdays.js';
import { parseTime } from './consts.js';
import { s as styles } from '../_helpers/date-picker.js';
import { jsxs, jsx } from 'react/jsx-runtime';
import 'classnames';
import '../_helpers/input.js';
import '@jetbrains/icons/close-12px';
import '../button/button.js';
import '@jetbrains/icons/chevron-down';
import '@jetbrains/icons/chevron-12px-down';
import 'util-deprecate';
import '../icon/icon.js';
import '../icon/icon.constants.js';
import '../_helpers/icon-svg.js';
import 'react-compiler-runtime';
import '../link/clickable-link.js';
import '../global/controls-height.js';
import '../global/configuration.js';
import '../_helpers/button.classes.js';
import '../global/get-uid.js';
import '../i18n/i18n-context.js';
import '../i18n/i18n.js';
import '../global/compose-refs.js';
import 'memoize-one';
import '../control-label/control-label.js';
import '../control-help/control-help.js';
import 'date-fns/addMonths';
import 'date-fns/getDay';
import 'date-fns/getDaysInMonth';
import 'date-fns/startOfMonth';
import 'date-fns/subMonths';
import 'date-fns/endOfMonth';
import '../global/schedule-raf.js';
import '../global/linear-function.js';
import '../global/use-event-callback.js';
import './month.js';
import 'date-fns/addDays';
import 'date-fns/format';
import 'date-fns/setDay';
import './day.js';
import 'date-fns/getDate';
import 'date-fns/isToday';
import 'date-fns/add';
import './month-names.js';
import 'date-fns/isThisMonth';
import 'date-fns/set';
import 'date-fns/startOfYear';
import './month-slider.js';
import 'date-fns/addYears';
import 'date-fns/subYears';
import 'date-fns/getYear';
import 'date-fns/isSameYear';
import 'date-fns/isThisYear';
import 'date-fns/setYear';

const scrollExpDelay = 10;
class DatePopup extends Component {
  static sameDay(next, prev) {
    if (next && prev) {
      return isSameDay(next, prev);
    }
    return next === prev;
  }
  static defaultProps = {
    onChange() {}
  };
  constructor(props) {
    super(props);
    const defaultState = {
      text: null,
      hoverDate: null,
      scrollDate: null
    };
    const {
      range,
      withTime
    } = props;
    if (!range) {
      const parsedDate = this.parse(props.date, 'date');
      const active = withTime && parsedDate && !props.time ? 'time' : 'date';
      this.state = {
        ...defaultState,
        active,
        scrollDate: parsedDate
      };
    } else {
      this.state = {
        ...defaultState,
        active: props.from && !props.to ? 'to' : 'from',
        scrollDate: this.parse(props.from, 'from')
      };
    }
  }
  componentDidMount() {
    if (this.componentRef.current) {
      this.componentRef.current.addEventListener('wheel', this.handleWheel);
    }
  }
  componentDidUpdate(prevProps, prevState) {
    if (this.state.active !== prevState.active) {
      if (this.state.text && prevState.active) {
        this.confirm(prevState.active);
      }
      this.setState({
        text: null
      });
    }
  }
  componentWillUnmount() {
    if (this.componentRef.current) {
      this.componentRef.current.removeEventListener('wheel', this.handleWheel);
    }
  }
  _scrollDate;
  _scrollTS;
  isInTimeMode = () => !this.props.range && this.props.withTime || false;
  componentRef = /*#__PURE__*/React.createRef();
  handleWheel = e => {
    if (e.cancelable) {
      e.preventDefault();
    }
  };
  parse(text, type) {
    if (type === 'time') {
      return parseTime(String(text));
    }
    return this.props.parseDateInput(text);
  }
  select(changes) {
    const {
      range,
      withTime
    } = this.props;
    const prevActive = this.state.active;
    if (!range && !withTime) {
      this.setState({
        text: null,
        scrollDate: null
      });
      const adjustedDate = changes.date && set(new Date(), {
        year: changes.date.getFullYear(),
        month: changes.date.getMonth(),
        date: changes.date.getDate()
      });
      this.props.onChange(adjustedDate);
      this.props.onComplete();
    } else if (!range && withTime) {
      const date = this.parse(this.props.date, 'date');
      const time = this.parse(this.props.time, 'time');
      const changeToSubmit = {
        date: changes.date || date,
        time: changes.time || time
      };
      this.setState({
        active: changes.date ? 'time' : 'date',
        text: null,
        scrollDate: null
      });
      this.props.onChange(changeToSubmit);
      if (!changes.date && prevActive === 'time' && changeToSubmit.date && changeToSubmit.time) {
        this.props.onComplete();
      }
    } else {
      let {
        from,
        to
      } = {
        ...this.props,
        ...changes
      };
      from = this.parse(from, 'from');
      to = this.parse(to, 'to');
      // proceed to setting the end by default
      let active = 'to';
      let complete = false;
      // end is before beginning
      if (from && to && isAfter(startOfDay(from), startOfDay(to))) {
        // ignore the old end when beginning is changed
        if (changes.from) {
          to = null;
          // treat range as reverse when end is changed
        } else if (changes.to) {
          to = from;
          from = changes.to;
        }
      } else if (changes.to) {
        active = 'from';
        complete = !!from;
      }
      this.setState({
        active,
        hoverDate: null,
        text: null
      });
      this.props.onChange({
        from,
        to
      });
      if (complete) {
        this.props.onComplete();
      }
    }
  }
  confirm(name) {
    const text = this.state.text;
    let result;
    if (name === 'time') {
      result = this.parse(text, name);
      const time = this.parse('time' in this.props ? this.props.time : '', 'time');
      const emptyCase = this.state.active === 'time' ? '00:00' : null;
      result = result || time || emptyCase;
    } else {
      result = this.parse(text, name);
      if (!this.isValidDate(result)) {
        result = this.parse(name in this.props ? this.props[name] : '', name);
      }
    }
    this.select({
      [name]: result
    });
  }
  isValidDate = parsedText => {
    const minDate = this.parse(this.props.minDate, 'date');
    const maxDate = this.parse(this.props.maxDate, 'date');
    if (parsedText) {
      return !(minDate && isBefore(parsedText, minDate) || maxDate && isAfter(parsedText, maxDate));
    }
    return false;
  };
  scheduleScroll = () => {
    const current = this.state.scrollDate && this.parse(this.state.scrollDate, 'date') || this.parse(this.props[this.state.active], 'date') || new Date();
    const goal = this._scrollDate;
    if (!current || !goal || DatePopup.sameDay(goal, current)) {
      this._scrollDate = null;
      this._scrollTS = null;
      return;
    }
    if (this._scrollTS) {
      const diff = goal - Number(current);
      const dt = Date.now() - this._scrollTS;
      const next = goal - diff * Math.E ** (-dt / scrollExpDelay);
      this.setState({
        scrollDate: next
      });
    }
    this._scrollTS = Date.now();
    window.requestAnimationFrame(this.scheduleScroll);
  };
  scrollTo = scrollDate => {
    this._scrollDate = scrollDate;
    if (!this._scrollTS) {
      this.scheduleScroll();
    }
  };
  hoverHandler = hoverDate => this.setState({
    hoverDate
  });
  handleActivate = memoize(name => () => this.setState({
    active: name
  }));
  handleInput = (text, name) => {
    if (name !== 'time') {
      const parsed = this.parse(text, name);
      if (this.isValidDate(parsed)) {
        this.scrollTo(Number(parsed));
      }
    }
    this.setState({
      text,
      hoverDate: null
    });
  };
  handleConfirm = memoize(name => () => this.confirm(name));
  selectHandler = date => {
    if (this.isInTimeMode()) {
      this.setState({
        active: 'time'
      }, () => this.select({
        date
      }));
    } else {
      this.select({
        [this.state.active]: date
      });
    }
  };
  handleScroll = scrollDate => this.setState({
    scrollDate
  });
  onClear = e => {
    let changes;
    if (this.props.range) {
      changes = {
        from: null,
        to: null
      };
    } else {
      changes = {
        date: null
      };
    }
    this.select(changes);
    this.props.onClear?.(e);
    this.componentRef.current?.querySelector('input')?.focus();
  };
  // eslint-disable-next-line complexity
  render() {
    const {
      range,
      locale
    } = this.props;
    const {
      from,
      to,
      date,
      time,
      ...restProps
    } = this.props;
    const parsedDate = this.parse(this.props.date, 'date');
    const parsedTo = this.parse(this.props.to, 'to');
    const names = range ? ['from', 'to'] : ['date'];
    const dates = names.reduce((obj, key) => {
      const value = this.props[key];
      return {
        ...obj,
        [key]: this.parse(value, key)
      };
    }, {});
    const activeDate = this.state.active !== 'time' ? this.state.hoverDate || (this.state.text ? this.parse(this.state.text, 'date') : null) : this.state.hoverDate || null;
    const currentRange = range && dates.from && dates.to && [dates.from, dates.to] || null;
    let activeRange = null;
    if (range && activeDate) {
      switch (this.state.active) {
        case 'from':
          if (dates.to && isAfter(startOfDay(activeDate), startOfDay(dates.to))) {
            activeRange = [activeDate, dates.to];
          }
          break;
        case 'to':
          if (!dates.from) {
            break;
          }
          if (isBefore(startOfDay(activeDate), startOfDay(dates.from))) {
            activeRange = [activeDate, dates.from];
          } else {
            activeRange = [dates.from, activeDate];
          }
          break;
      }
    }
    const scrollDate = this.state.scrollDate || new Date();
    const calendarProps = {
      ...restProps,
      ...dates,
      scrollDate,
      activeDate,
      currentRange,
      activeRange,
      onScroll: this.handleScroll,
      onScrollChange: this.scrollTo
    };
    const clearable = Boolean(this.props.onClear);
    return /*#__PURE__*/jsxs("div", {
      className: styles.datePopup,
      "data-test": "ring-date-popup",
      ref: this.componentRef,
      children: [/*#__PURE__*/jsxs("div", {
        className: styles.filterWrapper,
        children: [names.map(name => {
          let onClear;
          if (clearable && name !== 'from' && !this.isInTimeMode()) {
            onClear = this.onClear.bind(this);
          }
          return /*#__PURE__*/createElement(DateInput, {
            ...this.props,
            ...this.state,
            divider: name === 'from' && (!!dates[name] || !!parsedTo),
            name: name,
            key: name,
            date: dates[name],
            active: this.state.active === name,
            onActivate: this.handleActivate(name),
            onInput: this.handleInput,
            onConfirm: this.handleConfirm(name),
            onClear: onClear,
            locale: locale
          });
        }), this.isInTimeMode() ? /*#__PURE__*/createElement(DateInput, {
          ...this.props,
          text: this.state.text,
          divider: !!parsedDate,
          hoverDate: null,
          name: 'time',
          key: 'time',
          date: null,
          time: time,
          active: this.state.active === 'time',
          onActivate: this.handleActivate('time'),
          onInput: this.handleInput,
          onConfirm: this.handleConfirm('time'),
          onClear: clearable && this.onClear || undefined,
          locale: locale
        }) : '']
      }), /*#__PURE__*/jsx(Weekdays, {
        locale: locale
      }), /*#__PURE__*/jsxs("div", {
        className: styles.calendar,
        children: [/*#__PURE__*/jsx(Months, {
          ...calendarProps,
          onHover: this.hoverHandler,
          onSelect: this.selectHandler,
          locale: locale
        }), /*#__PURE__*/jsx(Years, {
          ...calendarProps
        })]
      }), this.props.renderAfterCalendar && this.props.renderAfterCalendar(this.state)]
    });
  }
}

export { DatePopup as default };
