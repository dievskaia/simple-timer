import PermissionCache, { type Permission } from './permissions-cache';
import type Auth from '../auth/auth-core';
export interface PermissionsConfig {
    prefix?: string | null | undefined;
    namesConverter?: ((name: string) => string) | null | undefined;
    services?: readonly string[] | null | undefined;
    datasource?: ((query: string | undefined) => Promise<readonly Permission[] | null | undefined>) | null | undefined;
}
interface PermissionsCacheControl {
    NO_CACHE?: boolean | null | undefined;
    NO_STORE?: boolean | null | undefined;
}
export interface PermissionsLoadOptions {
    cacheControl?: PermissionsCacheControl | null | undefined;
}
/**
 * <code>
 *   const permissions = new Permissions(auth, {prefix: 'jetbrains.jetpass.', services: [auth.serviceId]})
 *   permissions.load().then(function (p) {
 *     const canReadUser = p.has('read-user');
 *     ...
 *   });
 *
 *   permissions.check('read-user').then(function(canReadUser) {
 *     ...
 *   });
 * </code>
 *
 * @param {Auth} auth instance of well configured Auth object
 * @param {{
 *   prefix: string?,
 *   namesConverter: function?
 *   serviceId: string?
 * }=} config permissions loaded configuration.
 * <code>prefix</code> if provided then this prefix is removed from the permissions names.
 * <code>namesConverter</code> if provided it maps permission names used on server-side to client-side permission names. It is used only if prefix is undefined.
 * <code>serviceId</code> if provided then permissions only for the service are loaded.
 * @constructor
 */
export default class Permissions {
    /**
     * @const {string}
     */
    static API_PERMISSION_CACHE_PATH: string;
    query: string | undefined;
    namesConverter: ((name: string) => string) | null | undefined;
    private _auth;
    private _datasource;
    _promise: Promise<PermissionCache> | null;
    private _subscribed;
    private _permissionCache;
    constructor(auth: Auth, config?: PermissionsConfig);
    private _defaultDatasource;
    /**
     * Returns function, which cuts off prefix from server-side permission name
     *
     * @param {string} prefix
     * @mockReturnValue {Function}
     */
    static getDefaultNamesConverter(prefix: string): (storedName: string) => string;
    static getPermissionQuery(services?: readonly string[] | null | undefined): string | undefined;
    set(cachedPermissions?: readonly Permission[] | null | undefined): PermissionCache;
    get(): readonly Permission[] | null | undefined;
    private _setCache;
    private _getCache;
    private _resetCache;
    /**
     * Loads logged-in user permissions.
     * @param {object?} options
     * @return {Promise.<Permissions>} promise that is resolved when the permissions are loaded
     */
    load(options?: PermissionsLoadOptions | null | undefined): Promise<PermissionCache>;
    _loadPermissions(): Promise<readonly Permission[] | null | undefined>;
    /**
     * Reloads permission cache from server
     * @mockReturnValue {Promise.<Permissions>} promise that is resolved when the permissions are reloaded
     */
    reload(): Promise<PermissionCache>;
    /**
     * Waits till the permission cache is loaded then checks if the current user has the
     * given permissions in the project with the given id.
     *
     * @param {string} permissions  space separated list of permissions
     * @param {string=} projectId     optional projectId. If absent the method checks
     *  if the given permission is granted in any project.
     *
     * @return {Promise.<boolean>}
     */
    check(permissions?: string | null | undefined, projectId?: string | null | undefined): Promise<boolean>;
    /**
     * Binds a property with the name <code>propertyName</code> of the <code>object</code>
     * to a boolean value that is true if user has the permissions and false if she doesn't.
     *
     * @example
     * <code>
     *   userPermissions.bindVariable($scope, 'canReadRole', 'role-read')
     * </code>
     *
     * @param {object} object       an object which property should be bound
     * @param {string} propertyName a name of a property to bind
     * @param {string} permissions  space separated list of permissions
     * @param {string=} projectId     optional projectId. If absent the method checks
     *  if the given permissions are granted in any project.
     *
     * @return {Promise.<boolean>}
     */
    bindVariable<K extends string>(object: {
        [key in K]?: boolean;
    }, propertyName: K, permissions?: string | null | undefined, projectId?: string | null | undefined): Promise<boolean>;
}
export {};
