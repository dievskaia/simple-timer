import { c } from 'react-compiler-runtime';
import * as React from 'react';
import { useEffect } from 'react';
import classNames from 'classnames';
import Heading, { Levels } from '../heading/heading.js';
import { Button } from '../button/button.js';
import { S as Size, i as inputStyles } from '../_helpers/input.js';
import getUID from '../global/get-uid.js';
import Shortcuts from '../shortcuts/shortcuts.js';
import useEventCallback from '../global/use-event-callback.js';
import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import 'util-deprecate';
import '../_helpers/heading.js';
import '@jetbrains/icons/chevron-down';
import '@jetbrains/icons/chevron-12px-down';
import '../icon/icon.js';
import '../icon/icon.constants.js';
import '../_helpers/icon-svg.js';
import '../global/memoize.js';
import '../link/clickable-link.js';
import '../global/controls-height.js';
import '../global/configuration.js';
import '../_helpers/button.classes.js';
import '@jetbrains/icons/close-12px';
import '../i18n/i18n-context.js';
import '../i18n/i18n.js';
import '../global/compose-refs.js';
import 'memoize-one';
import '../control-label/control-label.js';
import '../control-help/control-help.js';
import '../shortcuts/core.js';
import 'combokeys';
import '../global/sniffer.js';
import 'sniffr';

var styles = {"editableHeading":"ring-editable-heading-editableHeading","fullSize":"ring-editable-heading-fullSize","isEditing":"ring-editable-heading-isEditing","headingWrapperButton":"ring-editable-heading-headingWrapperButton","disabled":"ring-editable-heading-disabled","selectionMode":"ring-editable-heading-selectionMode","heading":"ring-editable-heading-heading","multiline":"ring-editable-heading-multiline","input":"ring-editable-heading-input","error":"ring-editable-heading-error","textarea":"ring-editable-heading-textarea","textareaNotOverflow":"ring-editable-heading-textareaNotOverflow","textareaFade":"ring-editable-heading-textareaFade","textareaWrapper":"ring-editable-heading-textareaWrapper","button":"ring-editable-heading-button","errorText":"ring-editable-heading-errorText","level1":"ring-editable-heading-level1","level2":"ring-editable-heading-level2","level3":"ring-editable-heading-level3","sizeS":"ring-editable-heading-sizeS","sizeM":"ring-editable-heading-sizeM","sizeL":"ring-editable-heading-sizeL","sizeFULL":"ring-editable-heading-sizeFULL"};

function noop() {}
// eslint-disable-next-line complexity
const EditableHeading = props => {
  const $ = c(129);
  if ($[0] !== "337405178e721c40ff96461e6d67ef716cea1d26e0445aab59e026d687eab71d") {
    for (let $i = 0; $i < 129; $i += 1) {
      $[$i] = Symbol.for("react.memo_cache_sentinel");
    }
    $[0] = "337405178e721c40ff96461e6d67ef716cea1d26e0445aab59e026d687eab71d";
  }
  let children;
  let className;
  let dataTest;
  let disabled;
  let error;
  let headingClassName;
  let inputClassName;
  let maxInputRows;
  let onBlur;
  let onChange;
  let onFocus;
  let onScroll;
  let restProps;
  let t0;
  let t1;
  let t10;
  let t11;
  let t12;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  if ($[1] !== props) {
    ({
      level: t0,
      className,
      headingClassName,
      inputClassName,
      children,
      isEditing: t1,
      isSavingPossible: t2,
      isSaving: t3,
      embedded: t4,
      size: t5,
      onEdit: t6,
      onSave: t7,
      onCancel: t8,
      autoFocus: t9,
      "data-test": dataTest,
      error,
      disabled,
      multiline: t10,
      renderMenu: t11,
      onFocus,
      onBlur,
      onChange,
      onScroll,
      maxInputRows,
      translations: t12,
      ...restProps
    } = props);
    $[1] = props;
    $[2] = children;
    $[3] = className;
    $[4] = dataTest;
    $[5] = disabled;
    $[6] = error;
    $[7] = headingClassName;
    $[8] = inputClassName;
    $[9] = maxInputRows;
    $[10] = onBlur;
    $[11] = onChange;
    $[12] = onFocus;
    $[13] = onScroll;
    $[14] = restProps;
    $[15] = t0;
    $[16] = t1;
    $[17] = t10;
    $[18] = t11;
    $[19] = t12;
    $[20] = t2;
    $[21] = t3;
    $[22] = t4;
    $[23] = t5;
    $[24] = t6;
    $[25] = t7;
    $[26] = t8;
    $[27] = t9;
  } else {
    children = $[2];
    className = $[3];
    dataTest = $[4];
    disabled = $[5];
    error = $[6];
    headingClassName = $[7];
    inputClassName = $[8];
    maxInputRows = $[9];
    onBlur = $[10];
    onChange = $[11];
    onFocus = $[12];
    onScroll = $[13];
    restProps = $[14];
    t0 = $[15];
    t1 = $[16];
    t10 = $[17];
    t11 = $[18];
    t12 = $[19];
    t2 = $[20];
    t3 = $[21];
    t4 = $[22];
    t5 = $[23];
    t6 = $[24];
    t7 = $[25];
    t8 = $[26];
    t9 = $[27];
  }
  const level = t0 === undefined ? Levels.H1 : t0;
  const isEditing = t1 === undefined ? false : t1;
  const isSavingPossible = t2 === undefined ? false : t2;
  const isSaving = t3 === undefined ? false : t3;
  const embedded = t4 === undefined ? false : t4;
  const size = t5 === undefined ? Size.L : t5;
  const onEdit = t6 === undefined ? noop : t6;
  const onSave = t7 === undefined ? noop : t7;
  const onCancel = t8 === undefined ? noop : t8;
  const autoFocus = t9 === undefined ? true : t9;
  const multiline = t10 === undefined ? false : t10;
  const renderMenu = t11 === undefined ? _temp : t11;
  let t13;
  if ($[28] !== t12) {
    t13 = t12 === undefined ? {
      save: "Save",
      cancel: "Cancel"
    } : t12;
    $[28] = t12;
    $[29] = t13;
  } else {
    t13 = $[29];
  }
  const translations = t13;
  let t14;
  if ($[30] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = getUID("ring-editable-heading-");
    $[30] = t14;
  } else {
    t14 = $[30];
  }
  const [shortcutsScope] = React.useState(t14);
  const [isInFocus, setIsInFocus] = React.useState(false);
  const [isMouseDown, setIsMouseDown] = React.useState(false);
  const [isInSelectionMode, setIsInSelectionMode] = React.useState(false);
  const textAreaRef = React.useRef(null);
  const [isScrolledToBottom, setIsScrolledToBottom] = React.useState(false);
  const [isOverflow, setIsOverflow] = React.useState(false);
  const hasError = error !== undefined;
  let t15;
  if ($[31] !== children || $[32] !== hasError || $[33] !== isSaving || $[34] !== isSavingPossible) {
    t15 = !isSavingPossible || !children || children.trim() === "" || hasError || isSaving;
    $[31] = children;
    $[32] = hasError;
    $[33] = isSaving;
    $[34] = isSavingPossible;
    $[35] = t15;
  } else {
    t15 = $[35];
  }
  const isSaveDisabled = t15;
  const isCancelDisabled = isSaving;
  const isShortcutsDisabled = !isInFocus || isSaving;
  let shortcutsMap;
  if ($[36] !== isCancelDisabled || $[37] !== isSaveDisabled || $[38] !== onCancel || $[39] !== onSave) {
    shortcutsMap = {};
    if (!isSaveDisabled) {
      shortcutsMap.enter = onSave;
    }
    if (isCancelDisabled) {
      shortcutsMap.esc = onCancel;
    }
    $[36] = isCancelDisabled;
    $[37] = isSaveDisabled;
    $[38] = onCancel;
    $[39] = onSave;
    $[40] = shortcutsMap;
  } else {
    shortcutsMap = $[40];
  }
  const t16 = isEditing && size === Size.FULL;
  let t17;
  if ($[41] !== className || $[42] !== disabled || $[43] !== hasError || $[44] !== isEditing || $[45] !== isInSelectionMode || $[46] !== multiline || $[47] !== t16) {
    t17 = classNames(styles.editableHeading, className, {
      [styles.fullSize]: t16,
      [styles.isEditing]: isEditing,
      [styles.error]: hasError,
      [styles.disabled]: disabled,
      [styles.multiline]: multiline,
      [styles.selectionMode]: isInSelectionMode
    });
    $[41] = className;
    $[42] = disabled;
    $[43] = hasError;
    $[44] = isEditing;
    $[45] = isInSelectionMode;
    $[46] = multiline;
    $[47] = t16;
    $[48] = t17;
  } else {
    t17 = $[48];
  }
  const classes = t17;
  const t18 = styles[`size${size}`];
  let t19;
  if ($[49] !== headingClassName || $[50] !== t18) {
    t19 = classNames(styles.heading, headingClassName, t18);
    $[49] = headingClassName;
    $[50] = t18;
    $[51] = t19;
  } else {
    t19 = $[51];
  }
  const headingClasses = t19;
  const t20 = !isOverflow;
  let t21;
  if ($[52] !== inputClassName || $[53] !== level || $[54] !== size || $[55] !== t20) {
    t21 = classNames("ring-js-shortcuts", styles.input, styles.textarea, {
      [styles.textareaNotOverflow]: t20
    }, inputStyles[`size${size}`], styles[`level${level}`], inputClassName);
    $[52] = inputClassName;
    $[53] = level;
    $[54] = size;
    $[55] = t20;
    $[56] = t21;
  } else {
    t21 = $[56];
  }
  const inputClasses = t21;
  const stretch = _temp2;
  let t22;
  if ($[57] !== multiline) {
    t22 = el_0 => {
      if (multiline && el_0 && el_0.scrollHeight >= el_0.clientHeight) {
        stretch(el_0);
      }
    };
    $[57] = multiline;
    $[58] = t22;
  } else {
    t22 = $[58];
  }
  const checkValue = t22;
  let t23;
  if ($[59] === Symbol.for("react.memo_cache_sentinel")) {
    t23 = el_1 => {
      const scrollHeight = el_1.scrollHeight || 0;
      const clientHeight = el_1.clientHeight || 0;
      const scrollTop = el_1.scrollTop || 0;
      setIsScrolledToBottom(scrollHeight - clientHeight <= scrollTop);
      setIsOverflow(scrollHeight > clientHeight);
    };
    $[59] = t23;
  } else {
    t23 = $[59];
  }
  const checkOverflow = t23;
  let t24;
  if ($[60] === Symbol.for("react.memo_cache_sentinel")) {
    t24 = () => {
      setIsMouseDown(true);
    };
    $[60] = t24;
  } else {
    t24 = $[60];
  }
  const onHeadingMouseDown = t24;
  let t25;
  if ($[61] !== isMouseDown) {
    t25 = () => {
      if (!isMouseDown) {
        return;
      }
      setIsInSelectionMode(true);
    };
    $[61] = isMouseDown;
    $[62] = t25;
  } else {
    t25 = $[62];
  }
  const onMouseMove = useEventCallback(t25);
  let t26;
  if ($[63] !== disabled || $[64] !== isInSelectionMode || $[65] !== isMouseDown || $[66] !== onEdit) {
    t26 = () => {
      if (isMouseDown && !isInSelectionMode && !disabled) {
        onEdit();
      }
      setIsMouseDown(false);
      setIsInSelectionMode(false);
    };
    $[63] = disabled;
    $[64] = isInSelectionMode;
    $[65] = isMouseDown;
    $[66] = onEdit;
    $[67] = t26;
  } else {
    t26 = $[67];
  }
  const onMouseUp = useEventCallback(t26);
  let t27;
  if ($[68] !== checkValue || $[69] !== onFocus) {
    t27 = e => {
      setIsInFocus(true);
      checkValue(e.target);
      checkOverflow(e.target);
      onFocus?.(e);
    };
    $[68] = checkValue;
    $[69] = onFocus;
    $[70] = t27;
  } else {
    t27 = $[70];
  }
  const onInputFocus = t27;
  let t28;
  if ($[71] !== checkValue || $[72] !== onChange) {
    t28 = e_0 => {
      checkValue(e_0.target);
      checkOverflow(e_0.target);
      onChange?.(e_0);
    };
    $[71] = checkValue;
    $[72] = onChange;
    $[73] = t28;
  } else {
    t28 = $[73];
  }
  const onInputChange = t28;
  let t29;
  if ($[74] !== onScroll) {
    t29 = e_1 => {
      checkOverflow(e_1.target);
      onScroll?.(e_1);
    };
    $[74] = onScroll;
    $[75] = t29;
  } else {
    t29 = $[75];
  }
  const onInputScroll = t29;
  let t30;
  if ($[76] !== onBlur) {
    t30 = e_2 => {
      setIsInFocus(false);
      onBlur?.(e_2);
    };
    $[76] = onBlur;
    $[77] = t30;
  } else {
    t30 = $[77];
  }
  const onInputBlur = t30;
  let t31;
  let t32;
  if ($[78] !== onMouseMove || $[79] !== onMouseUp) {
    t31 = () => {
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
      return () => {
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("mouseup", onMouseUp);
      };
    };
    t32 = [onMouseMove, onMouseUp];
    $[78] = onMouseMove;
    $[79] = onMouseUp;
    $[80] = t31;
    $[81] = t32;
  } else {
    t31 = $[80];
    t32 = $[81];
  }
  useEffect(t31, t32);
  let t33;
  if ($[82] !== autoFocus || $[83] !== children || $[84] !== dataTest || $[85] !== disabled || $[86] !== headingClasses || $[87] !== inputClasses || $[88] !== isEditing || $[89] !== isSaving || $[90] !== isScrolledToBottom || $[91] !== isShortcutsDisabled || $[92] !== level || $[93] !== maxInputRows || $[94] !== multiline || $[95] !== onChange || $[96] !== onInputBlur || $[97] !== onInputChange || $[98] !== onInputFocus || $[99] !== onInputScroll || $[100] !== restProps || $[101] !== shortcutsMap || $[102] !== shortcutsScope || $[103] !== size) {
    t33 = !disabled && isEditing ? /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Shortcuts, {
        map: shortcutsMap,
        scope: shortcutsScope,
        disabled: isShortcutsDisabled
      }), !multiline ? /*#__PURE__*/jsx("input", {
        className: inputClasses,
        value: children,
        autoFocus: autoFocus,
        "data-test": dataTest,
        disabled: isSaving,
        onChange: onChange,
        ...restProps,
        onFocus: onInputFocus,
        onBlur: onInputBlur
      }) : /*#__PURE__*/jsxs("div", {
        className: classNames(styles.textareaWrapper, inputStyles[`size${size}`]),
        children: [/*#__PURE__*/jsx("textarea", {
          ref: textAreaRef,
          className: inputClasses,
          value: children,
          autoFocus: autoFocus,
          "data-test": dataTest,
          disabled: isSaving,
          onChange: onInputChange,
          ...restProps,
          onFocus: onInputFocus,
          onBlur: onInputBlur,
          onScroll: onInputScroll,
          style: {
            maxHeight: maxInputRows ? `${maxInputRows}lh` : ""
          }
        }), !isScrolledToBottom && /*#__PURE__*/jsx("div", {
          className: styles.textareaFade
        })]
      })]
    }) : /*#__PURE__*/jsx("button", {
      type: "button",
      className: styles.headingWrapperButton,
      onMouseDown: onHeadingMouseDown,
      children: /*#__PURE__*/jsx(Heading, {
        className: headingClasses,
        level: level,
        "data-test": dataTest,
        children: children
      })
    });
    $[82] = autoFocus;
    $[83] = children;
    $[84] = dataTest;
    $[85] = disabled;
    $[86] = headingClasses;
    $[87] = inputClasses;
    $[88] = isEditing;
    $[89] = isSaving;
    $[90] = isScrolledToBottom;
    $[91] = isShortcutsDisabled;
    $[92] = level;
    $[93] = maxInputRows;
    $[94] = multiline;
    $[95] = onChange;
    $[96] = onInputBlur;
    $[97] = onInputChange;
    $[98] = onInputFocus;
    $[99] = onInputScroll;
    $[100] = restProps;
    $[101] = shortcutsMap;
    $[102] = shortcutsScope;
    $[103] = size;
    $[104] = t33;
  } else {
    t33 = $[104];
  }
  let t34;
  if ($[105] !== isEditing || $[106] !== renderMenu) {
    t34 = !isEditing && renderMenu();
    $[105] = isEditing;
    $[106] = renderMenu;
    $[107] = t34;
  } else {
    t34 = $[107];
  }
  let t35;
  if ($[108] !== embedded || $[109] !== isCancelDisabled || $[110] !== isEditing || $[111] !== isSaveDisabled || $[112] !== isSaving || $[113] !== onCancel || $[114] !== onSave || $[115] !== translations) {
    t35 = isEditing && !embedded && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Button, {
        className: styles.button,
        primary: true,
        disabled: isSaveDisabled,
        loader: isSaving,
        onClick: onSave,
        children: translations.save
      }), /*#__PURE__*/jsx(Button, {
        className: styles.button,
        disabled: isCancelDisabled,
        onClick: onCancel,
        children: translations.cancel
      })]
    });
    $[108] = embedded;
    $[109] = isCancelDisabled;
    $[110] = isEditing;
    $[111] = isSaveDisabled;
    $[112] = isSaving;
    $[113] = onCancel;
    $[114] = onSave;
    $[115] = translations;
    $[116] = t35;
  } else {
    t35 = $[116];
  }
  let t36;
  if ($[117] !== classes || $[118] !== t33 || $[119] !== t34 || $[120] !== t35) {
    t36 = /*#__PURE__*/jsxs("div", {
      className: classes,
      children: [t33, t34, t35]
    });
    $[117] = classes;
    $[118] = t33;
    $[119] = t34;
    $[120] = t35;
    $[121] = t36;
  } else {
    t36 = $[121];
  }
  let t37;
  if ($[122] !== error || $[123] !== isEditing || $[124] !== size) {
    t37 = isEditing && error && /*#__PURE__*/jsx("div", {
      className: classNames(styles.errorText, inputStyles[`size${size}`]),
      children: error
    });
    $[122] = error;
    $[123] = isEditing;
    $[124] = size;
    $[125] = t37;
  } else {
    t37 = $[125];
  }
  let t38;
  if ($[126] !== t36 || $[127] !== t37) {
    t38 = /*#__PURE__*/jsxs(Fragment, {
      children: [t36, t37]
    });
    $[126] = t36;
    $[127] = t37;
    $[128] = t38;
  } else {
    t38 = $[128];
  }
  return t38;
};
var editableHeading = /*#__PURE__*/React.memo(EditableHeading);
function _temp() {
  return null;
}
function _temp2(el) {
  if (!el || !el.style) {
    return;
  }
  el.style.height = "0";
  const {
    paddingTop,
    paddingBottom
  } = window.getComputedStyle(el);
  el.style.height = `${el.scrollHeight - parseFloat(paddingTop) - parseFloat(paddingBottom)}px`;
}

export { EditableHeading, Levels, Size, editableHeading as default };
