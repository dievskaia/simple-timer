import Listeners, { type Handler } from '../global/listeners';
import HTTP, { type HTTPAuth, type RequestParams } from '../http/http';
import AuthStorage, { type AuthState } from './storage';
import { type AuthError, type AuthResponse } from './response-parser';
import AuthRequestBuilder from './request-builder';
import BackgroundFlow from './background-flow';
import TokenValidator, { type TokenValidationError, type TokenValidatorConfig } from './token-validator';
import type AuthDialogService from '../auth-dialog-service/auth-dialog-service';
export declare const DEFAULT_EXPIRES_TIMEOUT: number;
export declare const DEFAULT_BACKGROUND_TIMEOUT: number;
export declare const USER_CHANGED_EVENT = "userChange";
export declare const DOMAIN_USER_CHANGED_EVENT = "domainUser";
export declare const LOGOUT_EVENT = "logout";
export declare const LOGOUT_POSTPONED_EVENT = "logoutPostponed";
export declare const USER_CHANGE_POSTPONED_EVENT = "changePostponed";
export interface AuthUser {
    guest?: boolean;
    id: string;
    name: string;
    login: string;
    banned?: boolean;
    banReason?: string;
    profile?: {
        avatar?: {
            url?: string;
        };
        email?: {
            email?: string;
        };
    };
}
export interface AuthTranslations {
    login: string;
    loginTo: string;
    cancel: string;
    postpone: string;
    youHaveLoggedInAs: string;
    applyChange: string;
    backendIsNotAvailable: string;
    checkAgain: string;
    tryAgainLabel: string;
    nothingHappensLink: string;
    errorMessage: string;
}
export interface LoginFlow {
    stop(): void;
    authorize(): Promise<unknown>;
}
export interface LoginFlowClass {
    new (requestBuilder: AuthRequestBuilder, storage: AuthStorage, translations: AuthTranslations): LoginFlow;
}
export interface BackendDownParams {
    onCheckAgain(): Promise<void>;
    onPostpone(): void;
    backendError: Error;
    translations: AuthTranslations;
}
export interface AuthConfig extends TokenValidatorConfig {
    serverUri: string;
    redirectUri: string;
    requestCredentials: string;
    clientId: string;
    redirect: boolean;
    cleanHash: boolean;
    userFields: readonly string[];
    fetchCredentials?: RequestCredentials | null | undefined;
    cacheCurrentUser: boolean;
    reloadOnUserChange: boolean;
    embeddedLogin: boolean;
    EmbeddedLoginFlow?: LoginFlowClass | null | undefined;
    backgroundRefreshTimeout?: number | null | undefined;
    onLogout?: (() => void) | null | undefined;
    onPostponeChangedUser: (prevUser: AuthUser | null, nextUser: AuthUser | null) => void;
    onPostponeLogout: () => void;
    enableBackendStatusCheck: boolean;
    backendCheckTimeout: number;
    checkBackendIsUp: () => Promise<unknown>;
    onBackendDown: (params: BackendDownParams) => () => void;
    defaultExpiresIn: number;
    translations?: AuthTranslations | null | undefined;
    userParams?: RequestParams | undefined;
    waitForRedirectTimeout: number;
}
type AuthPayloadMap = {
    userChange: [AuthUser | undefined | void, void];
    logout: [void, void];
    logoutPostponed: [void, void];
    changePostponed: [void, void];
};
export interface AuthService {
    serviceName: string;
    serviceImage: string;
}
interface Deferred<T> {
    promise?: Promise<T>;
    resolve?: (value: T) => void;
    reject?: (reason: unknown) => void;
}
interface AuthDialogParams {
    nonInteractive?: boolean;
    error?: Error;
    canCancel?: boolean;
    onTryAgain?: () => Promise<void>;
}
interface UserChange {
    userID: number | string | null | undefined;
    serviceID: string;
}
interface UserChangedDialogParams {
    newUser: AuthUser;
    onApply: () => void;
    onPostpone: () => void;
}
declare global {
    interface HTMLLinkElement {
        pr?: string;
    }
}
declare class Auth implements HTTPAuth {
    static DEFAULT_CONFIG: Omit<AuthConfig, "serverUri">;
    static API_PATH: string;
    static API_AUTH_PATH: string;
    static API_PROFILE_PATH: string;
    static CLOSE_BACKEND_DOWN_MESSAGE: string;
    static CLOSE_WINDOW_MESSAGE: string;
    static shouldRefreshToken: typeof TokenValidator.shouldRefreshToken;
    static storageIsUnavailable: boolean;
    config: AuthConfig;
    listeners: Listeners<AuthPayloadMap>;
    http: HTTP;
    private _service;
    readonly _storage: AuthStorage<number>;
    private _responseParser;
    private readonly _requestBuilder;
    _backgroundFlow: BackgroundFlow | null;
    private _embeddedFlow;
    _tokenValidator: TokenValidator | null;
    private _postponed;
    private _backendCheckPromise;
    private _authDialogService;
    _domainStorage: AuthStorage<UserChange>;
    user: AuthUser | null;
    _initDeferred?: Deferred<string | void>;
    private _isLoginWindowOpen?;
    constructor(config: Partial<AuthConfig> & Pick<AuthConfig, 'serverUri'>);
    private _setPostponed;
    private _updateDomainUser;
    addListener<E extends keyof AuthPayloadMap>(event: E, handler: Handler<AuthPayloadMap, E>): void;
    removeListener<E extends keyof AuthPayloadMap>(event: E, handler: Handler<AuthPayloadMap, E>): void;
    setAuthDialogService(authDialogService: typeof AuthDialogService): void;
    setCurrentService(service: AuthService): void;
    private _createInitDeferred;
    /**
     * @return {Promise.<string>} absolute URL promise that is resolved to a URL
     * that should be restored after returning back from auth server.
     */
    init(): Promise<string | null | undefined>;
    sendRedirect(error: Error): Promise<undefined>;
    handleInitError(error: Error | AuthError): Promise<undefined>;
    handleInitValidationError(error: Error | TokenValidationError): Promise<undefined>;
    /**
     * Get token from local storage or request it if necessary.
     * Can redirect to login page.
     * @return {Promise.<string>}
     */
    requestToken(): Promise<string | null>;
    /**
     * Get new token in the background or redirect to the login page.
     * @return {Promise.<string>}
     */
    forceTokenUpdate(): Promise<string | null>;
    loadCurrentService(): Promise<void>;
    getAPIPath(): string;
    /**
     * @return {Promise.<object>}
     */
    getUser(accessToken?: string | null | undefined): Promise<any>;
    /**
     * @return {Promise.<object>}
     */
    requestUser(): Promise<any>;
    updateUser(): Promise<void>;
    _detectUserChange(accessToken: string): Promise<void>;
    _beforeLogout(params?: AuthDialogParams): void;
    _showAuthDialog({ nonInteractive, error, canCancel, onTryAgain }?: AuthDialogParams): void;
    _showUserChangedDialog({ newUser, onApply, onPostpone }: UserChangedDialogParams): void;
    private _extractErrorMessage;
    private _showBackendDownDialog;
    /**
     * Wipe accessToken and redirect to auth page with required authorization
     */
    logout(extraParams?: Record<string, unknown>): Promise<void>;
    private _runEmbeddedLogin;
    /**
     * Wipe accessToken and redirect to auth page to obtain authorization data
     * if user is logged in or log her in otherwise
     */
    login(): Promise<void>;
    switchUser(): Promise<void>;
    _makeStateFromResponse(authResponse: AuthResponse): AuthState | null;
    /**
     * Check if the hash contains an access token.
     * If it does, extract the state, compare with
     * config, and store the auth response for later use.
     *
     * @return {Promise} promise that is resolved to restoreLocation URL, or rejected
     * @private
     */
    private _checkForAuthResponse;
    private _checkForStateRestoration;
    _checkBackendsAreUp(): Promise<[unknown, unknown]>;
    private _checkBackendsStatusesIfEnabled;
    /**
     * Adds preconnect tag to help browser to establish connection to URL.
     * See https://w3c.github.io/resource-hints/
     * @param url Url to preconnect to.
     */
    setUpPreconnect(url: string): void;
    /**
     * Redirects current page to the given URL
     * @param {string} url
     * @private
     */
    _redirectCurrentPage(url: string): void;
    /**
     * Reloads current page
     */
    private _reloadCurrentPage;
    _canShowDialogs(): false | typeof AuthDialogService | undefined;
    /**
     * Sets the location hash
     * @param {string} hash
     */
    setHash(hash: string): void;
}
export default Auth;
export { Auth };
