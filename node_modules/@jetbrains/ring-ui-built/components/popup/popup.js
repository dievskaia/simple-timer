import { PureComponent } from 'react';
import { createPortal } from 'react-dom';
import classNames from 'classnames';
import getUID from '../global/get-uid.js';
import scheduleRAF from '../global/schedule-raf.js';
import { Listeners, getStyles } from '../global/dom.js';
import Shortcuts from '../shortcuts/shortcuts.js';
import joinDataTestAttributes from '../global/data-tests.js';
import TabTrap from '../tab-trap/tab-trap.js';
import { getConfiguration } from '../global/configuration.js';
import position from './position.js';
import { DEFAULT_DIRECTIONS, Display, MaxHeight, MinWidth, Dimension, Directions } from './popup.consts.js';
import { PopupTargetContext, normalizePopupTarget, PopupTarget } from './popup.target.js';
import { supportsCSSAnchorPositioning, setCSSAnchorPositioning } from './position-css.js';
import { b as ThemeContext, W as WithThemeClasses } from '../_helpers/theme.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import '../shortcuts/core.js';
import 'combokeys';
import '../global/sniffer.js';
import 'sniffr';
import 'react-compiler-runtime';

var styles = {"popup":"ring-popup-popup ring-global-font","cssAnchoredPopup":"ring-popup-cssAnchoredPopup","largeBorderRadius":"ring-popup-largeBorderRadius","hidden":"ring-popup-hidden","showing":"ring-popup-showing","attached":"ring-popup-attached"};

const getPopupContainer = target => typeof target === 'string' ? document.querySelector(`[data-portaltarget=${target}]`) : target;
/**
 * @constructor
 * @name Popup
 * @extends {ReactComponent}
 */
class Popup extends PureComponent {
  static defaultProps = {
    shortcuts: true,
    hidden: false,
    onOutsideClick() {},
    onEscPress() {},
    onCloseAttempt() {},
    dontCloseOnAnchorClick: false,
    keepMounted: false,
    directions: DEFAULT_DIRECTIONS,
    autoPositioning: true,
    autoPositioningOnScroll: true,
    autoCorrectTopOverflow: true,
    left: 0,
    top: 0,
    offset: 0,
    sidePadding: 8,
    attached: false,
    trapFocus: false,
    autoFocusFirst: false,
    legacy: false
  };
  state = {
    display: Display.SHOWING
  };
  componentDidMount() {
    if (!this.props.hidden) {
      this._setListenersEnabled(true);
    }
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      hidden
    } = this.props;
    if (this.props !== prevProps) {
      if (prevProps.hidden !== hidden) {
        this._setListenersEnabled(!hidden);
      }
      this._redraw();
    }
    if (this.props.onShow && !hidden && this.state.display === Display.SHOWN && (prevProps.hidden || prevState.display !== Display.SHOWN)) {
      this.props.onShow();
    }
  }
  componentWillUnmount() {
    this._setListenersEnabled(false);
  }
  popup;
  node;
  parent;
  container;
  ringPopupTarget;
  cssPositioningFromContext;
  clickStartedInsidePopup = false;
  shouldUseShortcuts() {
    const {
      shortcuts,
      hidden
    } = this.props;
    return shortcuts && !hidden;
  }
  listeners = new Listeners();
  redrawScheduler = scheduleRAF(true);
  uid = getUID('popup-');
  calculateDisplay = prevState => ({
    ...prevState,
    display: this.props.hidden ? Display.SHOWING : Display.SHOWN
  });
  static PopupProps = {
    Directions,
    Dimension,
    MinWidth,
    MaxHeight
  };
  portalRef = el => {
    this.node = el;
    this.parent = el && el.parentElement;
    if (el && this.getContainer()) {
      this._redraw();
    }
  };
  popupRef = el => {
    this.popup = el;
    this._redraw();
  };
  containerRef = el => {
    this.container = el;
  };
  getContainer() {
    const target = this.props.target || this.ringPopupTarget;
    return target && getPopupContainer(target);
  }
  position() {
    const {
      directions,
      autoPositioning,
      autoCorrectTopOverflow,
      sidePadding,
      top,
      left,
      offset,
      maxHeight,
      minWidth
    } = this.props;
    const container = this.getContainer();
    return position({
      popup: this.popup,
      container: container && getStyles(container).position !== 'static' ? container : null,
      anchor: this._getAnchor(),
      directions,
      autoPositioning,
      autoCorrectTopOverflow,
      sidePadding,
      top,
      left,
      offset,
      maxHeight,
      minWidth
    });
  }
  _updateDirection = newDirection => {
    if (this.state.direction !== newDirection) {
      this.setState({
        direction: newDirection
      });
      if (this.props.onDirectionChange) {
        this.props.onDirectionChange(newDirection);
      }
    }
  };
  shouldUseCssPositioning() {
    var _ref, _this$props$cssPositi;
    if (!supportsCSSAnchorPositioning()) {
      return false;
    }
    return (_ref = (_this$props$cssPositi = this.props.cssPositioning) !== null && _this$props$cssPositi !== void 0 ? _this$props$cssPositi : this.cssPositioningFromContext) !== null && _ref !== void 0 ? _ref : getConfiguration().popupsCssPositioning;
  }
  _updatePosition = () => {
    const popup = this.popup;
    const anchor = this._getAnchor();
    if (popup) {
      if (this.shouldUseCssPositioning() && anchor) {
        // Use CSS Anchor positioning
        setCSSAnchorPositioning({
          popup,
          anchor,
          uid: this.uid,
          minWidth: this.props.minWidth,
          top: this.props.top,
          left: this.props.left,
          directions: this.props.directions,
          offset: this.props.offset
        });
        const {
          direction
        } = this.position();
        if (direction) {
          this._updateDirection(direction);
        }
      } else {
        popup.style.position = 'absolute';
        if (this.isVisible()) {
          const {
            styles: style,
            direction
          } = this.position();
          Object.entries(style).forEach(([key, value]) => {
            const propKey = key;
            if (typeof value === 'number') {
              popup.style[propKey] = `${value}px`;
            } else {
              popup.style[propKey] = value.toString();
            }
          });
          if (direction) {
            this._updateDirection(direction);
          }
        }
      }
      this.setState(this.calculateDisplay);
    }
  };
  _redraw = () => {
    if (this.isVisible()) {
      this.redrawScheduler(this._updatePosition);
    }
  };
  _getAnchor() {
    return this.props.anchorElement || this.parent;
  }
  _listenersEnabled;
  _prevTimeout;
  /**
   * @param {boolean} enable
   * @private
   */
  _setListenersEnabled(enable) {
    if (enable && !this._listenersEnabled) {
      clearTimeout(this._prevTimeout);
      this._prevTimeout = window.setTimeout(() => {
        this._listenersEnabled = true;
        // CSS positioning doesn't need resize/scroll listeners as it's handled by CSS
        // But we need them if CSS positioning isn't supported
        if (!this.shouldUseCssPositioning()) {
          this.listeners.add(window, 'resize', this._redraw);
          if (this.props.autoPositioningOnScroll) {
            this.listeners.add(window, 'scroll', this._redraw);
          }
          let el = this._getAnchor();
          while (el) {
            this.listeners.add(el, 'scroll', this._redraw);
            el = el.parentElement;
          }
        }
        this.listeners.add(document, 'pointerdown', this._onDocumentPointerDown, true);
        this.listeners.add(document, 'click', this._onDocumentClick, true);
      }, 0);
      return;
    }
    if (!enable && this._listenersEnabled) {
      this.listeners.removeAll();
      clearTimeout(this._prevTimeout);
      this._listenersEnabled = false;
    }
  }
  /**
   * Returns visibility state
   * @return {boolean}
   */
  isVisible() {
    return !this.props.hidden;
  }
  _onCloseAttempt(evt, isEsc) {
    this.props.onCloseAttempt(evt, isEsc);
  }
  _onEscPress = evt => {
    this.props.onEscPress(evt);
    this._onCloseAttempt(evt, true);
  };
  _onDocumentPointerDown = evt => {
    this.clickStartedInsidePopup = !!(evt.target instanceof Node && this.container && this.container.contains(evt.target));
  };
  /**
   * @param {MouseEvent} evt
   * @private
   */
  _onDocumentClick = evt => {
    const clickStartedInsidePopup = this.clickStartedInsidePopup;
    this.clickStartedInsidePopup = false;
    if (this.container && evt.target instanceof Node && this.container.contains(evt.target) || clickStartedInsidePopup || !this._listenersEnabled || this.props.dontCloseOnAnchorClick && evt.target instanceof Node && this._getAnchor()?.contains(evt.target) ||
    // ignore clicks in shadow DOM, e.g., Grammarly suggestions
    evt.target instanceof Element && evt.target.shadowRoot) {
      return;
    }
    this.props.onOutsideClick(evt);
    this._onCloseAttempt(evt, false);
  };
  getInternalContent() {
    const {
      trapFocus,
      autoFocusFirst,
      children
    } = this.props;
    return trapFocus ? /*#__PURE__*/jsx(TabTrap, {
      autoFocusFirst: autoFocusFirst,
      focusBackOnExit: true,
      children: children
    }) : children;
  }
  shortcutsScope = this.uid;
  shortcutsMap = {
    esc: this._onEscPress
  };
  render() {
    const {
      className,
      style,
      hidden,
      attached,
      keepMounted,
      client,
      onMouseDown,
      onMouseUp,
      onMouseOver,
      onMouseOut,
      onContextMenu,
      'data-test': dataTest,
      largeBorderRadius
    } = this.props;
    const showing = this.state.display === Display.SHOWING;
    const direction = (this.state.direction || '').toLowerCase().replace(/[_]/g, '-');
    return /*#__PURE__*/jsx(ThemeContext.Consumer, {
      children: theme => /*#__PURE__*/jsx(WithThemeClasses, {
        theme: theme.theme,
        children: themeClasses => /*#__PURE__*/jsx(PopupTargetContext.Consumer, {
          children: value => {
            this.ringPopupTarget = normalizePopupTarget(value);
            if (!(typeof value === 'string' || value instanceof Element)) {
              this.cssPositioningFromContext = value?.cssPositioning;
            }
            const classes = classNames(className, theme.passToPopups ? themeClasses : null, styles.popup, {
              [styles.cssAnchoredPopup]: this.shouldUseCssPositioning(),
              [styles.attached]: attached,
              [styles.hidden]: hidden,
              [styles.showing]: showing,
              [styles.largeBorderRadius]: largeBorderRadius
            });
            return /*#__PURE__*/jsxs("span", {
              ref: this.portalRef,
              children: [this.shouldUseShortcuts() && /*#__PURE__*/jsx(Shortcuts, {
                map: this.shortcutsMap,
                scope: this.shortcutsScope
              }), client !== false && (keepMounted || !hidden) && /*#__PURE__*/createPortal(/*#__PURE__*/jsx(PopupTarget, {
                id: this.uid,
                ref: this.containerRef,
                onMouseOver: onMouseOver,
                onFocus: onMouseOver,
                onMouseOut: onMouseOut,
                onBlur: onMouseOut,
                onContextMenu: onContextMenu,
                children: /*#__PURE__*/jsx("div", {
                  "data-test": joinDataTestAttributes('ring-popup', dataTest),
                  "data-test-shown": !hidden && !showing,
                  "data-test-direction": direction,
                  ref: this.popupRef,
                  className: classes,
                  style: style,
                  onMouseDown: onMouseDown,
                  onMouseUp: onMouseUp
                  // mouse handlers are used to track clicking on inner elements
                  ,
                  role: "presentation",
                  children: this.getInternalContent()
                })
              }), this.getContainer() || document.body)]
            });
          }
        })
      })
    });
  }
}

export { PopupTarget, PopupTargetContext, Popup as default, getPopupContainer };
