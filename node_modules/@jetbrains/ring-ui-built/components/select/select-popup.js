import { PureComponent } from 'react';
import classNames from 'classnames';
import searchIcon from '@jetbrains/icons/search';
import memoizeOne from 'memoize-one';
import Icon from '../icon/icon.js';
import Popup, { getPopupContainer } from '../popup/popup.js';
import { maxHeightForDirection } from '../popup/position.js';
import { PopupTargetContext, normalizePopupTarget } from '../popup/popup.target.js';
import List from '../list/list.js';
import LoaderInline from '../loader-inline/loader-inline.js';
import shortcutsHOC from '../shortcuts/shortcuts-hoc.js';
import { getStyles } from '../global/dom.js';
import getUID from '../global/get-uid.js';
import memoize from '../global/memoize.js';
import TagsList from '../tags-list/tags-list.js';
import Caret from '../caret/caret.js';
import Shortcuts from '../shortcuts/shortcuts.js';
import { Button } from '../button/button.js';
import Text from '../text/text.js';
import '../global/controls-height.js';
import { createComposedRef } from '../global/compose-refs.js';
import { DEFAULT_DIRECTIONS } from '../popup/popup.consts.js';
import { s as styles, S as SelectFilter } from '../_helpers/select-filter.js';
import { jsxs, jsx } from 'react/jsx-runtime';
import { ControlsHeight } from '../global/configuration.js';
import 'util-deprecate';
import '../icon/icon.constants.js';
import '../_helpers/icon-svg.js';
import 'react-compiler-runtime';
import 'react-dom';
import '../global/schedule-raf.js';
import '../global/data-tests.js';
import '../tab-trap/tab-trap.js';
import '../popup/position-css.js';
import '../_helpers/theme.js';
import 'react-virtualized/dist/es/List';
import 'react-virtualized/dist/es/AutoSizer';
import 'react-virtualized/dist/es/WindowScroller';
import 'react-virtualized/dist/es/CellMeasurer';
import '../global/create-stateful-context.js';
import '../list/list-item.js';
import '../avatar/avatar.js';
import '../global/url.js';
import '../avatar/fallback-avatar.js';
import '../avatar/avatar-size.js';
import '../_helpers/avatar-info.js';
import '../checkbox/checkbox.js';
import '@jetbrains/icons/checkmark-12px';
import '@jetbrains/icons/remove-12px';
import '../control-help/control-help.js';
import '../link/link.js';
import '../link/clickable-link.js';
import '../_helpers/link.js';
import '../list/consts.js';
import '../list/list.classes.js';
import '../_helpers/list.js';
import '../list/list-custom.js';
import '../global/get-event-key.js';
import '../list/list-title.js';
import '../list/list-separator.js';
import '../list/list-hint.js';
import '../shortcuts/core.js';
import 'combokeys';
import '../global/sniffer.js';
import 'sniffr';
import '../tag/tag.js';
import '@jetbrains/icons/close-12px';
import '@jetbrains/icons/chevron-down';
import '@jetbrains/icons/chevron-12px-down';
import '../_helpers/button.classes.js';
import '../_helpers/input.js';
import '../i18n/i18n-context.js';
import '../i18n/i18n.js';
import '../control-label/control-label.js';

const FILTER_HEIGHT = 35;
const TOOLBAR_HEIGHT = 49;
function noop() {}
const FilterWithShortcuts = shortcutsHOC(SelectFilter);
class SelectPopup extends PureComponent {
  static defaultProps = {
    data: [],
    activeIndex: null,
    toolbar: null,
    topbar: null,
    filter: false,
    filterIcon: null,
    filterRef: noop,
    multiple: false,
    message: null,
    anchorElement: null,
    maxHeight: 600,
    minWidth: 240,
    loading: false,
    onSelect: noop,
    onCloseAttempt: noop,
    onOutsideClick: noop,
    onFilter: noop,
    onClear: noop,
    onLoadMore: noop,
    selected: [],
    tags: null,
    ringPopupTarget: null,
    onSelectAll: noop,
    onEmptyPopupEnter: noop
  };
  state = {
    popupFilterShortcutsOptions: {
      modal: true,
      disabled: true
    },
    tagsActiveIndex: null
  };
  componentDidMount() {
    window.document.addEventListener('mouseup', this.mouseUpHandler);
  }
  componentWillUnmount() {
    window.document.removeEventListener('mouseup', this.mouseUpHandler);
  }
  isClickingPopup = false; // This flag is set to true while an item in the popup is being clicked
  filter;
  focusFilter() {
    setTimeout(() => this.filter?.focus());
  }
  isEventTargetFilter(event) {
    return event.target instanceof Element && event.target.matches('input,textarea');
  }
  caret;
  handleNavigation(event, navigateLeft) {
    if (this.isEventTargetFilter(event) && this.caret && Number(this.caret?.getPosition()) > 0 || !Array.isArray(this.props.selected)) {
      return;
    }
    let newIndex = null;
    if (navigateLeft) {
      newIndex = this.state.tagsActiveIndex === null ? this.props.selected.length - 1 : this.state.tagsActiveIndex - 1;
    } else if (this.state.tagsActiveIndex !== null) {
      newIndex = this.state.tagsActiveIndex + 1;
    }
    if (newIndex !== null && (newIndex >= this.props.selected.length || newIndex < 0)) {
      newIndex = null;
      this.focusFilter();
    }
    this.setState({
      tagsActiveIndex: newIndex
    });
  }
  removeTag(tag, event) {
    if (!Array.isArray(this.props.selected)) {
      return;
    }
    // eslint-disable-next-line no-underscore-dangle
    const _tag = tag || this.props.selected.slice(0)[this.props.selected.length - 1];
    if (_tag) {
      this.onListSelect(_tag, event, {
        tryKeepOpen: true
      });
      this.setState({
        tagsActiveIndex: null
      });
      this.focusFilter();
    }
  }
  removeSelectedTag() {
    if (Array.isArray(this.props.selected) && this.state.tagsActiveIndex !== null && this.state.tagsActiveIndex !== undefined) {
      this.removeTag(this.props.selected[this.state.tagsActiveIndex]);
      return false;
    }
    return true;
  }
  handleBackspace(event) {
    if (!this.props.tags) {
      return true;
    }
    if (!this.isEventTargetFilter(event)) {
      this.removeSelectedTag();
      return false;
    }
    if ((event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) && !event.target.value) {
      this.removeTag();
      return false;
    }
    return true;
  }
  onFilterFocus = () => {
    this._togglePopupFilterShortcuts(false);
    this.setState({
      tagsActiveIndex: null
    });
  };
  popupFilterOnBlur = () => {
    if (this.state.tagsActiveIndex === null) {
      this._togglePopupFilterShortcuts(true);
    }
  };
  _togglePopupFilterShortcuts(shortcutsDisabled) {
    this.setState({
      popupFilterShortcutsOptions: {
        modal: true,
        disabled: shortcutsDisabled
      }
    });
  }
  mouseDownHandler = () => {
    this.isClickingPopup = true;
  };
  mouseUpHandler = () => {
    this.isClickingPopup = false;
  };
  popup;
  isVisible() {
    return this.popup && this.popup.isVisible();
  }
  onListSelect = (selected, event, opts) => {
    const getSelectItemEvent = () => {
      const customEvent = document.createEvent('Event');
      customEvent.initEvent('select', true, false);
      if (event && 'persist' in event) {
        event.persist();
      }
      customEvent.originalEvent = event;
      return customEvent;
    };
    this.props.onSelect(selected, getSelectItemEvent(), opts);
  };
  tabPress = event => {
    this.props.onCloseAttempt(event, true);
  };
  onClickHandler = () => this.filter?.focus();
  getFilter() {
    if (this.props.filter || this.props.tags) {
      var _this$props$filterIco;
      return /*#__PURE__*/jsxs("div", {
        className: styles.filterWrapper,
        "data-test": "ring-select-popup-filter",
        children: [!this.props.tags && /*#__PURE__*/jsx(Icon, {
          glyph: (_this$props$filterIco = this.props.filterIcon) !== null && _this$props$filterIco !== void 0 ? _this$props$filterIco : searchIcon,
          className: styles.filterIcon,
          "data-test-custom": "ring-select-popup-filter-icon"
        }), /*#__PURE__*/jsx(FilterWithShortcuts, {
          rgShortcutsOptions: this.state.popupFilterShortcutsOptions,
          rgShortcutsMap: this.popupFilterShortcutsMap,
          value: this.props.filterValue,
          inputRef: this.composedFilterRef(this.filterRef, this.props.filterRef),
          onBlur: this.popupFilterOnBlur,
          onFocus: this.onFilterFocus,
          className: "ring-js-shortcuts",
          inputClassName: classNames({
            [styles.filterWithTagsInput]: this.props.tags
          }),
          placeholder: typeof this.props.filter === 'object' ? this.props.filter.placeholder : undefined,
          height: this.props.tags ? ControlsHeight.S : ControlsHeight.L,
          onChange: this.props.onFilter,
          onClick: this.onClickHandler,
          onClear: this.props.tags ? undefined : this.props.onClear,
          "data-test-custom": "ring-select-popup-filter-input",
          listId: this.props.listId,
          enableShortcuts: Object.keys(this.popupFilterShortcutsMap)
        })]
      });
    }
    return null;
  }
  handleRemoveTag = memoize(tag => event => this.removeTag(tag, event));
  handleTagClick = memoize(tag => () => {
    if (Array.isArray(this.props.selected)) {
      this.setState({
        tagsActiveIndex: this.props.selected.indexOf(tag)
      });
    }
  });
  getCustomTag(tags) {
    if (tags !== null && typeof tags !== 'boolean') {
      return tags.customTagComponent;
    }
    return undefined;
  }
  getTags() {
    return Array.isArray(this.props.selected) && /*#__PURE__*/jsx("div", {
      children: /*#__PURE__*/jsx(TagsList, {
        tags: this.props.selected,
        activeIndex: this.state.tagsActiveIndex,
        handleRemove: this.handleRemoveTag,
        handleClick: this.handleTagClick,
        disabled: this.props.disabled,
        customTagComponent: this.getCustomTag(this.props.tags)
      })
    });
  }
  getFilterWithTags() {
    if (this.props.tags) {
      const classes = classNames([styles.filterWithTags, {
        [styles.filterWithTagsFocused]: !this.state.popupFilterShortcutsOptions.disabled
      }]);
      return /*#__PURE__*/jsxs("div", {
        className: classes,
        children: [this.getTags(), this.getFilter()]
      });
    }
    return this.getFilter();
  }
  getBottomLine() {
    const {
      loading,
      message,
      data
    } = this.props;
    const hasMoreThanOneItem = data.length > 1;
    return (loading || message) && /*#__PURE__*/jsxs("div", {
      className: classNames(styles.bottomLine, {
        [styles.bottomLineOverItem]: hasMoreThanOneItem
      }),
      children: [loading && /*#__PURE__*/jsx(LoaderInline, {}), message && /*#__PURE__*/jsx("div", {
        className: styles.message,
        children: message
      })]
    });
  }
  handleListResize = () => {
    this.forceUpdate();
  };
  getList(ringPopupTarget) {
    if (this.props.data.length) {
      let {
        maxHeight
      } = this.props;
      if (this.props.anchorElement) {
        maxHeight = this._adjustListMaxHeight(this.props.hidden, maxHeight, ringPopupTarget);
      }
      if (this.props.filter) {
        maxHeight -= FILTER_HEIGHT;
      }
      if (this.props.toolbar) {
        maxHeight -= TOOLBAR_HEIGHT;
      }
      return /*#__PURE__*/jsx(List, {
        id: this.props.listId,
        maxHeight: maxHeight,
        data: this.props.data,
        activeIndex: this.props.activeIndex,
        ref: this.listRef,
        restoreActiveIndex: true,
        activateFirstItem: true,
        onSelect: this.onListSelect,
        onResize: this.handleListResize,
        onScrollToBottom: this.props.onLoadMore,
        hidden: this.props.hidden,
        shortcuts: !this.props.hidden,
        disableMoveOverflow: this.props.disableMoveOverflow,
        disableMoveDownOverflow: this.props.loading,
        disableScrollToActive: this.props.disableScrollToActive,
        compact: this.props.compact,
        preventListOverscroll: this.props.preventListOverscroll,
        renderOptimization: this.props.renderOptimization
      });
    }
    return null;
  }
  handleSelectAll = () => {
    if (Array.isArray(this.props.selected)) {
      this.props.onSelectAll(this.props.data.filter(item => !item.disabled).length !== this.props.selected.length);
    }
  };
  getSelectAll = () => {
    const multiple = this.props.multiple;
    const activeFilters = this.props.data.filter(item => !item.disabled);
    return Array.isArray(this.props.selected) && /*#__PURE__*/jsxs("div", {
      className: styles.selectAll,
      children: [activeFilters.length === 0 ? /*#__PURE__*/jsx("span", {}) : /*#__PURE__*/jsx(Button, {
        inline: true,
        onClick: this.handleSelectAll,
        children: activeFilters.length !== this.props.selected.length ? multiple.selectAllLabel || 'Select all' : multiple.deselectAllLabel || 'Deselect all'
      }), multiple.renderSelectedItemsDescription?.(this.props.selected, activeFilters.length) || /*#__PURE__*/jsx(Text, {
        info: true,
        children: `${this.props.selected.length} selected`
      })]
    });
  };
  // Cache the value because this method is called
  // inside `render` function which can be called N times
  // and should be fast as possible.
  // Cache invalidates each time hidden or userDefinedMaxHeight changes
  _adjustListMaxHeight = memoizeOne((hidden, userDefinedMaxHeight, ringPopupTarget) => {
    if (hidden) {
      return userDefinedMaxHeight;
    }
    // Calculate list's maximum height that can't
    // get beyond the screen
    // @see RG-1838, JT-48358
    const minMaxHeight = 100;
    const directions = this.props.directions || DEFAULT_DIRECTIONS;
    // Note:
    // Create a method which'll be called only when the popup opens and before
    // render the list would be a better way
    const anchorNode = this.props.anchorElement;
    const containerNode = getPopupContainer(ringPopupTarget) || document.documentElement;
    return anchorNode !== null ? Math.min(directions.reduce((maxHeight, direction) => {
      var _maxHeightForDirectio;
      return Math.max(maxHeight, (_maxHeightForDirectio = maxHeightForDirection(direction, anchorNode, getStyles(containerNode).position !== 'static' ? containerNode : null)) !== null && _maxHeightForDirectio !== void 0 ? _maxHeightForDirectio : 0);
    }, minMaxHeight), userDefinedMaxHeight) : userDefinedMaxHeight;
  });
  popupRef = el => {
    this.popup = el;
  };
  list;
  listRef = el => {
    this.list = el;
  };
  filterRef = el => {
    this.filter = el;
    this.caret = el && new Caret(el);
  };
  composedFilterRef = createComposedRef();
  shortcutsScope = getUID('select-popup-');
  shortcutsMap = {
    tab: this.tabPress
  };
  popupFilterShortcutsMap = {
    up: event => this.list && this.list.upHandler(event),
    down: event => this.list && this.list.downHandler(event),
    home: event => this.list && this.list.homeHandler(event),
    end: event => this.list && this.list.endHandler(event),
    enter: event => this.list ? this.list.enterHandler(event) : this.props.onEmptyPopupEnter(event),
    esc: event => this.props.onCloseAttempt(event, true),
    tab: event => this.tabPress(event),
    backspace: event => this.handleBackspace(event),
    del: () => this.removeSelectedTag(),
    left: event => this.handleNavigation(event, true),
    right: event => this.handleNavigation(event)
  };
  render() {
    const {
      toolbar,
      topbar,
      className,
      multiple,
      hidden,
      isInputMode,
      anchorElement,
      minWidth,
      onCloseAttempt,
      onOutsideClick,
      directions,
      top,
      left,
      offset,
      style,
      dir,
      filter
    } = this.props;
    const classes = classNames(styles.popup, className);
    return /*#__PURE__*/jsx(PopupTargetContext.Consumer, {
      children: ringPopupTarget => {
        const filterWithTags = this.getFilterWithTags();
        const selectAll = multiple && typeof multiple === 'object' && !multiple.limit && multiple.selectAll && this.getSelectAll();
        const list = this.getList(this.props.ringPopupTarget || normalizePopupTarget(ringPopupTarget));
        const bottomLine = this.getBottomLine();
        const hasContent = filterWithTags || selectAll || list || bottomLine || toolbar || topbar;
        return /*#__PURE__*/jsx(Popup, {
          trapFocus: false,
          ref: this.popupRef,
          hidden: hidden || !hasContent,
          attached: isInputMode,
          className: classes,
          dontCloseOnAnchorClick: true,
          anchorElement: anchorElement,
          minWidth: minWidth,
          onCloseAttempt: onCloseAttempt,
          onOutsideClick: onOutsideClick,
          directions: directions,
          top: top,
          left: left,
          offset: offset,
          onMouseDown: this.mouseDownHandler,
          target: this.props.ringPopupTarget,
          autoCorrectTopOverflow: false,
          style: style,
          largeBorderRadius: true,
          children: /*#__PURE__*/jsxs("div", {
            dir: dir,
            children: [!hidden && filter && /*#__PURE__*/jsx(Shortcuts, {
              map: this.shortcutsMap,
              scope: this.shortcutsScope
            }), topbar, hidden ? /*#__PURE__*/jsx("div", {}) : filterWithTags, selectAll, list, bottomLine, toolbar]
          })
        });
      }
    });
  }
}

export { SelectPopup as default };
