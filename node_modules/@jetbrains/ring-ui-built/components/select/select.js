import { Component, Fragment } from 'react';
import classNames from 'classnames';
import chevronDownIcon from '@jetbrains/icons/chevron-down';
import closeIcon from '@jetbrains/icons/close-12px';
import { dequal } from 'dequal';
import joinDataTestAttributes from '../global/data-tests.js';
import { isArray } from '../global/typescript-utils.js';
import { A as Anchor } from '../_helpers/anchor.js';
import { jsx, jsxs, Fragment as Fragment$1 } from 'react/jsx-runtime';
import Avatar from '../avatar/avatar.js';
import Popup from '../popup/popup.js';
import List, { ActiveItemContext } from '../list/list.js';
import { S as Size, I as Input, i as inputStyles } from '../_helpers/input.js';
import { ControlLabel } from '../control-label/control-label.js';
import Shortcuts from '../shortcuts/shortcuts.js';
import { Button } from '../button/button.js';
import getUID from '../global/get-uid.js';
import rerenderHOC from '../global/rerender-hoc.js';
import fuzzyHighlight from '../global/fuzzy-highlight.js';
import memoize from '../global/memoize.js';
import { I18nContext } from '../i18n/i18n-context.js';
import { createComposedRef } from '../global/compose-refs.js';
import { ControlsHeightContext } from '../global/controls-height.js';
import SelectPopup from './select-popup.js';
import { ControlsHeight } from '../global/configuration.js';
import { Size as Size$1 } from '../avatar/avatar-size.js';
import 'react-compiler-runtime';
import 'util-deprecate';
import '../global/url.js';
import '../global/dom.js';
import '../avatar/fallback-avatar.js';
import '../_helpers/avatar-info.js';
import 'react-dom';
import '../global/schedule-raf.js';
import '../tab-trap/tab-trap.js';
import '../popup/position.js';
import '../popup/popup.consts.js';
import '../popup/popup.target.js';
import '../popup/position-css.js';
import '../_helpers/theme.js';
import '../shortcuts/core.js';
import 'combokeys';
import '../global/sniffer.js';
import 'sniffr';
import 'react-virtualized/dist/es/List';
import 'react-virtualized/dist/es/AutoSizer';
import 'react-virtualized/dist/es/WindowScroller';
import 'react-virtualized/dist/es/CellMeasurer';
import 'memoize-one';
import '../global/create-stateful-context.js';
import '../list/list-item.js';
import '../checkbox/checkbox.js';
import '@jetbrains/icons/checkmark-12px';
import '@jetbrains/icons/remove-12px';
import '../icon/icon.js';
import '../icon/icon.constants.js';
import '../_helpers/icon-svg.js';
import '../control-help/control-help.js';
import '../link/link.js';
import '../link/clickable-link.js';
import '../_helpers/link.js';
import '../list/consts.js';
import '../list/list.classes.js';
import '../_helpers/list.js';
import '../list/list-custom.js';
import '../global/get-event-key.js';
import '../list/list-title.js';
import '../list/list-separator.js';
import '../list/list-hint.js';
import '@jetbrains/icons/chevron-12px-down';
import '../_helpers/button.classes.js';
import '../i18n/i18n.js';
import '@jetbrains/icons/search';
import '../loader-inline/loader-inline.js';
import '../shortcuts/shortcuts-hoc.js';
import '../tags-list/tags-list.js';
import '../tag/tag.js';
import '../caret/caret.js';
import '../text/text.js';
import '../_helpers/select-filter.js';

var styles = {"select":"ring-select-select","value":"ring-select-value ring-global-ellipsis ring-global-font","icons":"ring-select-icons","toolbar":"ring-select-toolbar","button":"ring-select-button","buttonSpaced":"ring-select-buttonSpaced","inputMode":"ring-select-inputMode","heightS":"ring-select-heightS","heightL":"ring-select-heightL","selectedIcon":"ring-select-selectedIcon ring-global-resetButton","clearIcon":"ring-select-clearIcon","sizeS":"ring-select-sizeS","sizeM":"ring-select-sizeM","sizeL":"ring-select-sizeL","sizeFULL":"ring-select-sizeFULL","sizeAUTO":"ring-select-sizeAUTO","buttonMode":"ring-select-buttonMode","open":"ring-select-open","buttonContainer":"ring-select-buttonContainer","buttonValue":"ring-select-buttonValue ring-global-ellipsis","buttonValueOpen":"ring-select-buttonValueOpen","buttonValueEmpty":"ring-select-buttonValueEmpty","label":"ring-select-label","disabled":"ring-select-disabled","avatar":"ring-select-avatar","popup":"ring-select-popup","chevron":"ring-select-chevron","chevronIcon":"ring-select-chevronIcon"};

function noop() {}
/**
 * @enum {number}
 */
var Type;
(function (Type) {
  Type["BUTTON"] = "BUTTON";
  Type["INPUT"] = "INPUT";
  Type["CUSTOM"] = "CUSTOM";
  Type["INLINE"] = "INLINE";
  Type["INPUT_WITHOUT_CONTROLS"] = "INPUT_WITHOUT_CONTROLS";
})(Type || (Type = {}));
const ICONS_OFFSET = 5;
const ICON_WIDTH = 20;
const getStyle = memoize(iconsLength => ({
  paddingRight: ICONS_OFFSET + iconsLength * ICON_WIDTH
}));
const isInputMode = type => type === Type.INPUT || type === Type.INPUT_WITHOUT_CONTROLS;
function getLowerCaseLabel(item) {
  if (List.isItemType(List.ListProps.Type.SEPARATOR, item) || List.isItemType(List.ListProps.Type.HINT, item) || typeof item.label !== 'string') {
    return null;
  }
  return item.label.toLowerCase();
}
function doesLabelMatch(itemToCheck, fn) {
  const lowerCaseLabel = getLowerCaseLabel(itemToCheck);
  if (lowerCaseLabel === null || lowerCaseLabel === undefined) {
    return true;
  }
  return fn(lowerCaseLabel);
}
function getFilterFn(filter) {
  if (typeof filter === 'object') {
    if (filter.fn) {
      return filter.fn;
    }
    if (filter.fuzzy) {
      return (itemToCheck, checkString) => doesLabelMatch(itemToCheck, lowerCaseLabel => fuzzyHighlight(checkString, lowerCaseLabel).matched);
    }
  }
  return (itemToCheck, checkString) => doesLabelMatch(itemToCheck, lowerCaseLabel => lowerCaseLabel.indexOf(checkString) >= 0);
}
function buildMultipleMap(selected) {
  return selected.reduce((acc, item) => {
    acc[item.key] = true;
    return acc;
  }, {});
}
// eslint-disable-next-line complexity
function getListItems(props, state, rawFilterString, data = props.data) {
  let filterString = rawFilterString.trim();
  if (isInputMode(props.type) && !props.allowAny && state.selected && !Array.isArray(state.selected) && filterString === state.selected.label) {
    filterString = ''; // ignore multiple if it is exactly the selected item
  }
  const lowerCaseString = filterString.toLowerCase();
  const filteredData = [];
  let exactMatch = false;
  const check = getFilterFn(props.filter);
  for (let i = 0; i < data.length; i++) {
    const item = {
      ...data[i]
    };
    if (check(item, lowerCaseString, data)) {
      exactMatch = item.label === filterString;
      if (props.multiple && !(typeof props.multiple === 'object' && props.multiple.removeSelectedItems)) {
        item.checkbox = !!state.multipleMap?.[item.key];
      }
      if (props.multiple && typeof props.multiple === 'object' && props.multiple.limit && Array.isArray(state.selected)) {
        item.disabled = props.multiple.limit === state.selected.length && !state.selected.find(selectedItem => selectedItem.key === item.key);
      }
      // Ignore item if it's multiple and is already selected
      if (!(props.multiple && typeof props.multiple === 'object' && props.multiple.removeSelectedItems && state.multipleMap?.[item.key])) {
        filteredData.push(item);
      }
    }
  }
  let addButton = null;
  const {
    add
  } = props;
  if (add && filterString && !exactMatch || add && add.alwaysVisible) {
    if (!(add.regexp && !add.regexp.test(filterString)) && !(add.minlength && filterString.length < +add.minlength) || add.alwaysVisible) {
      var _add$delayed;
      let label;
      if (add.label) {
        label = typeof add.label === 'function' ? add.label(filterString) : add.label;
      } else {
        label = filterString;
      }
      addButton = {
        prefix: add.prefix,
        label,
        delayed: (_add$delayed = add.delayed) !== null && _add$delayed !== void 0 ? _add$delayed : true
      };
    }
  }
  return {
    filteredData,
    addButton
  };
}
const getItemLabel = ({
  selectedLabel,
  label
}) => {
  if (selectedLabel !== null && selectedLabel !== undefined) {
    return selectedLabel;
  }
  return typeof label === 'string' ? label : '';
};
const getValueForFilter = (selected, type, filterValue) => selected && !isArray(selected) && isInputMode(type) ? getItemLabel(selected) : filterValue;
/**
 * @name Select
 * @constructor
 * @extends {Component}
 */
/**
 * Displays a select.
 */
class Select extends Component {
  static defaultProps = {
    data: [],
    filter: false,
    // enable filter (not in INPUT modes)
    filterIcon: null,
    filterRef: noop,
    multiple: false,
    // multiple can be an object - see demo for more information
    clear: false,
    // enable clear button that clears the "selected" state
    loading: false,
    // show a loading indicator while data is loading
    disabled: false,
    // disable select
    type: Type.BUTTON,
    size: Size.M,
    targetElement: null,
    // element to bind the popup to (select BUTTON or INPUT by default)
    hideSelected: false,
    // INPUT mode: clears the input after an option is selected (useful when the selection is displayed in some custom way elsewhere)
    allowAny: false,
    // INPUT mode: allows any value to be entered
    hideArrow: false,
    // hide dropdown arrow icon
    showPopup: false,
    maxHeight: 600,
    // height of the options list, including the filter and the 'Add' button
    directions: [Popup.PopupProps.Directions.BOTTOM_RIGHT, Popup.PopupProps.Directions.BOTTOM_LEFT, Popup.PopupProps.Directions.TOP_LEFT, Popup.PopupProps.Directions.TOP_RIGHT],
    selected: null,
    // current selection (item / array of items)
    label: null,
    // BUTTON or INPUT label (nothing selected)
    selectedLabel: null,
    // BUTTON or INPUT label (something selected)
    inputPlaceholder: '',
    // Placeholder for input modes
    hint: null,
    // hint text to display under the list
    shortcutsEnabled: false,
    onBeforeOpen: noop,
    onLoadMore: noop,
    onOpen: noop,
    onClose: noop,
    onFilter: noop,
    // search string as first argument
    onFocus: noop,
    onBlur: noop,
    onKeyDown: noop,
    onSelect: noop,
    // single + multi
    onDeselect: noop,
    // multi
    onOutsideClick: noop,
    // multi
    onChange: noop,
    // multi
    onAdd: noop,
    // search string as first argument
    onDone: noop,
    onReset: noop,
    tags: null,
    ringPopupTarget: null,
    dir: 'ltr',
    offset: 4
  };
  static getDerivedStateFromProps(nextProps, prevState) {
    const {
      multiple,
      data,
      type
    } = nextProps;
    const {
      prevSelected,
      prevData,
      prevMultiple,
      filterValue
    } = prevState;
    const nextState = {
      prevData: data,
      prevSelected: nextProps.selected,
      prevMultiple: multiple
    };
    if ('data' in nextProps && data !== prevData) {
      const {
        filteredData,
        addButton
      } = getListItems(nextProps, prevState, filterValue, data);
      Object.assign(nextState, {
        shownData: filteredData,
        addButton
      });
      if (prevState.selected) {
        Object.assign(nextState, {
          filterValue: getValueForFilter(prevState.selected, type, filterValue)
        });
      }
    }
    if ('selected' in nextProps && nextProps.selected !== prevSelected) {
      const selected = nextProps.selected || (multiple ? [] : null);
      Object.assign(nextState, {
        selected,
        filterValue: getValueForFilter(selected, type, filterValue)
      });
    }
    if (prevMultiple !== multiple && !dequal(prevMultiple, multiple)) {
      nextState.selected = multiple ? [] : null;
    }
    if (multiple && !nextState.selected) {
      nextState.selected = prevState.selected;
    }
    const {
      selected
    } = {
      ...prevState,
      ...nextState
    };
    if (selected && Array.isArray(selected)) {
      nextState.multipleMap = buildMultipleMap(selected);
      const {
        filteredData,
        addButton
      } = getListItems(nextProps, nextState, filterValue, data);
      Object.assign(nextState, {
        shownData: filteredData,
        addButton
      });
    }
    const isSelectionEmpty = nextProps.selected === null || nextProps.selected === undefined || Array.isArray(nextProps.selected) && nextProps.selected.length === 0;
    if (isSelectionEmpty) {
      nextState.lastInteractedKey = null;
    }
    return nextState;
  }
  state = {
    data: [],
    shownData: [],
    selected: this.props.multiple ? [] : null,
    lastInteractedKey: null,
    filterValue: this.props.filter && typeof this.props.filter === 'object' && this.props.filter.value || '',
    shortcutsEnabled: false,
    popupShortcuts: false,
    showPopup: this.props.showPopup,
    prevData: [],
    prevSelected: null,
    prevMultiple: this.props.multiple,
    multipleMap: {},
    addButton: null
  };
  componentDidUpdate(prevProps, prevState) {
    const {
      showPopup,
      selected
    } = this.state;
    const {
      onClose,
      onOpen,
      onChange,
      multiple
    } = this.props;
    if (prevState.showPopup && !showPopup) {
      onClose(selected);
    } else if (!prevState.showPopup && showPopup) {
      onOpen();
    }
    if (multiple !== prevProps.multiple && !dequal(multiple, prevProps.multiple)) {
      onChange(selected);
    }
  }
  static contextType = ControlsHeightContext;
  static Type = Type;
  static Size = Size;
  id = getUID('select-');
  shortcutsScope = this.id;
  listId = `${this.id}:list`;
  _focusHandler = e => {
    this.props.onFocus(e);
    this.setState({
      shortcutsEnabled: true,
      focused: true
    });
  };
  isClickingSelect = false;
  mouseDownHandler = () => {
    this.isClickingSelect = true;
  };
  mouseUpHandler = () => {
    this.isClickingSelect = false;
  };
  _blurHandler = () => {
    this.props.onBlur();
    if (this._popup && this._popup.isVisible() && !this._popup.isClickingPopup && !this.isClickingSelect) {
      window.setTimeout(() => {
        this.setState({
          showPopup: false
        });
      });
    }
    if (!this._popup?.isClickingPopup) {
      this.setState({
        shortcutsEnabled: false,
        focused: false
      });
    }
  };
  node;
  nodeRef = el => {
    this.node = el;
  };
  _popup = null;
  onEmptyPopupEnter = () => {
    if (this.state.addButton) {
      this.addHandler();
    }
  };
  focus = () => {
    const focusableSelectExists = this.node?.querySelector('[data-test~=ring-select__focus]');
    const restoreFocusNode = this.props.targetElement || focusableSelectExists;
    restoreFocusNode?.focus();
  };
  _onEnter = () => {
    if (this.state.addButton && this.state.shownData.length === 0) {
      this.addHandler();
    }
    this.props.onDone();
    if (!this._popup?.isVisible() && this.props.allowAny) {
      return true;
    }
    return undefined;
  };
  _onEsc = event => {
    if (!this._popup?.isVisible()) {
      return true;
    }
    if (this.props.multiple || !this.props.getInitial) {
      return false;
    }
    const selected = {
      key: Math.random(),
      label: this.props.getInitial()
    };
    this.setState({
      selected,
      filterValue: this.getValueForFilter(selected)
    }, () => {
      this.props.onChange(selected, event);
      this.props.onReset();
    });
    return undefined;
  };
  _inputShortcutHandler = () => {
    if (this.state.focused && this._popup && !this._popup.isVisible()) {
      this._clickHandler();
    }
  };
  getValueForFilter(selected) {
    return getValueForFilter(selected, this.props.type, this.state.filterValue);
  }
  _getActiveIndex(items) {
    const {
      selected,
      lastInteractedKey
    } = this.state;
    const isNonOptionItem = item => item.isResetItem || List.isItemType(List.ListProps.Type.SEPARATOR, item);
    if (lastInteractedKey !== null && lastInteractedKey !== undefined) {
      const index = items.findIndex(item => item.key === lastInteractedKey && !isNonOptionItem(item));
      if (index >= 0) return index;
    }
    let selectedItems = [];
    if (Array.isArray(selected)) {
      selectedItems = selected;
    } else if (selected) {
      selectedItems = [selected];
    }
    if (selectedItems.length > 0) {
      const lastSelected = selectedItems[selectedItems.length - 1];
      const index = items.findIndex(item => item.key === lastSelected.key);
      if (index >= 0) return index;
    }
    return null;
  }
  popupRef = el => {
    this._popup = el;
  };
  _getResetOption() {
    const isOptionsSelected = Array.isArray(this.state.selected) && this.state.selected.length;
    const reset = this.props.tags && typeof this.props.tags === 'object' ? this.props.tags.reset : null;
    if (!isOptionsSelected || !reset) {
      return null;
    }
    const resetHandler = (item, event) => {
      this.clear(event);
      this.clearFilter();
      this.props.onFilter('');
      this.setState(prevState => ({
        shownData: prevState.shownData.slice(reset.separator ? 2 : 1),
        multipleMap: {}
      }));
      this._redrawPopup();
    };
    return {
      isResetItem: true,
      separator: reset.separator,
      key: reset.label,
      rgItemType: List.ListProps.Type.CUSTOM,
      template: /*#__PURE__*/jsx(Button, {
        inline: true,
        className: styles.button,
        "data-test": "ring-select-reset-tags-button",
        height: ControlsHeight.S,
        children: reset.label
      }),
      glyph: reset.glyph,
      onClick: resetHandler
    };
  }
  _prependResetOption(shownData) {
    const resetOption = this._getResetOption();
    if (resetOption) {
      const resetItems = [resetOption];
      if (resetOption.separator) {
        resetItems.push({
          rgItemType: List.ListProps.Type.SEPARATOR
        });
      }
      return resetItems.concat(shownData);
    }
    return shownData;
  }
  _renderPopup() {
    const anchorElement = this.props.targetElement || this.node;
    const {
      showPopup,
      shownData
    } = this.state;
    // eslint-disable-next-line no-underscore-dangle
    const _shownData = this._prependResetOption(shownData);
    const activeIndex = this._getActiveIndex(_shownData);
    return /*#__PURE__*/jsx(I18nContext.Consumer, {
      children: ({
        translate
      }) => {
        let message;
        if (this.props.loading) {
          var _this$props$loadingMe;
          message = (_this$props$loadingMe = this.props.loadingMessage) !== null && _this$props$loadingMe !== void 0 ? _this$props$loadingMe : translate('loading');
        } else if (!shownData.length) {
          var _this$props$notFoundM;
          message = (_this$props$notFoundM = this.props.notFoundMessage) !== null && _this$props$notFoundM !== void 0 ? _this$props$notFoundM : translate('noOptionsFound');
        }
        return /*#__PURE__*/jsx(SelectPopup, {
          data: _shownData,
          message: message,
          toolbar: showPopup && this.getToolbar(),
          topbar: this.getTopbar(),
          loading: this.props.loading,
          activeIndex: activeIndex,
          hidden: !showPopup,
          ref: this.popupRef,
          maxHeight: this.props.maxHeight,
          minWidth: this.props.minWidth,
          directions: this.props.directions,
          className: this.props.popupClassName,
          style: this.props.popupStyle,
          top: this.props.top,
          left: this.props.left,
          offset: this.props.offset,
          filter: this.isInputMode() ? false : this.props.filter // disable popup filter in INPUT mode
          ,
          filterIcon: this.props.filterIcon,
          filterRef: this.props.filterRef,
          multiple: this.props.multiple,
          filterValue: this.state.filterValue,
          anchorElement: anchorElement,
          onCloseAttempt: this._onCloseAttempt,
          onOutsideClick: this.props.onOutsideClick,
          onSelect: this._listSelectHandler,
          onSelectAll: this._listSelectAllHandler,
          onFilter: this._filterChangeHandler,
          onClear: this.clearFilter,
          onLoadMore: this.props.onLoadMore,
          isInputMode: this.isInputMode(),
          selected: this.state.selected,
          tags: this.props.tags,
          compact: this.props.compact,
          renderOptimization: this.props.renderOptimization,
          ringPopupTarget: this.props.ringPopupTarget,
          disableMoveOverflow: this.props.disableMoveOverflow,
          disableScrollToActive: this.props.disableScrollToActive,
          dir: this.props.dir,
          onEmptyPopupEnter: this.onEmptyPopupEnter,
          listId: this.listId,
          preventListOverscroll: this.props.preventListOverscroll
        });
      }
    });
  }
  _showPopup = () => {
    if (!this.node) {
      return;
    }
    const shownData = this.getListItems(this.filterValue());
    this.setState({
      showPopup: true,
      shownData
    });
  };
  _hidePopup = tryFocusAnchor => {
    if (this.node && this.state.showPopup) {
      this.setState(prevState => ({
        showPopup: false,
        filterValue: this.props.allowAny ? prevState.filterValue : '',
        lastInteractedKey: null
      }));
      if (tryFocusAnchor) {
        this.focus();
      }
    }
  };
  addHandler = () => {
    const value = this.filterValue();
    this._hidePopup();
    this.props.onAdd(value);
  };
  getToolbar() {
    const {
      hint,
      renderBottomToolbar
    } = this.props;
    const {
      prefix,
      label,
      delayed
    } = this.state.addButton || {};
    const isToolbarHasElements = this.state.addButton || hint || renderBottomToolbar;
    if (!isToolbarHasElements) {
      return null;
    }
    return /*#__PURE__*/jsxs("div", {
      className: classNames({
        [styles.toolbar]: Boolean(this.state.addButton || renderBottomToolbar)
      }, this.props.toolbarClassName),
      "data-test": "ring-select-toolbar",
      children: [renderBottomToolbar && renderBottomToolbar(), this.state.addButton && /*#__PURE__*/jsx(Button, {
        inline: true,
        delayed: delayed,
        className: classNames(styles.button, styles.buttonSpaced),
        onClick: this.addHandler,
        "data-test": "ring-select-toolbar-button",
        children: prefix ? `${prefix} ${label}` : label
      }), hint && /*#__PURE__*/jsx(List.ListHint, {
        label: hint,
        "data-test": "ring-select-toolbar-hint"
      })]
    });
  }
  getTopbar() {
    return this.props.renderTopToolbar?.();
  }
  getLowerCaseLabel = getLowerCaseLabel;
  doesLabelMatch = doesLabelMatch;
  getFilterFn() {
    return getFilterFn(this.props.filter);
  }
  getListItems(rawFilterString, data) {
    const {
      filteredData,
      addButton
    } = getListItems(this.props, this.state, rawFilterString, data);
    this.setState({
      addButton
    });
    return filteredData;
  }
  filterValue(setValue) {
    if (typeof setValue === 'string' || typeof setValue === 'number') {
      this.setState({
        filterValue: setValue
      });
      return undefined;
    }
    return this.state.filterValue;
  }
  isInputMode() {
    return isInputMode(this.props.type);
  }
  _clickHandler = () => {
    if (!this.props.disabled) {
      if (this.state.showPopup) {
        this._hidePopup();
      } else {
        this.props.onBeforeOpen();
        this._showPopup();
      }
    }
  };
  _openPopupIfClosed = () => {
    if (this.props.disabled || this.state.showPopup) {
      return;
    }
    this.props.onBeforeOpen();
    this._showPopup();
  };
  _filterChangeHandler = e => {
    this._setFilter(e.currentTarget.value, e);
  };
  _setFilter = (value, event) => {
    if (this.isInputMode() && !this.state.focused) {
      return;
    }
    if (value === this.state.filterValue) {
      return;
    }
    const filterValue = value.replace(/^\s+/g, '');
    this.props.onFilter(filterValue);
    if (this.props.allowAny) {
      const fakeSelected = {
        key: Math.random(),
        label: filterValue
      };
      this.setState({
        selected: filterValue === '' ? null : fakeSelected
      }, () => {
        this.props.onSelect(fakeSelected, event);
        this.props.onChange(fakeSelected, event);
      });
    }
    if (!this._popup?.isVisible()) {
      this.props.onBeforeOpen();
    }
    this.setState({
      filterValue
    }, () => {
      this._showPopup();
    });
  };
  _rebuildMultipleMap(selected) {
    if (Array.isArray(selected)) {
      this.setState({
        multipleMap: buildMultipleMap(selected)
      });
    }
  }
  _redrawPopup = () => {
    if (this.props.multiple) {
      setTimeout(() => {
        //setTimeout solves events order and bubbling issue
        if (this.isInputMode()) {
          this.clearFilter();
        }
        this._showPopup();
      }, 0);
    }
  };
  _listSelectHandler = (selected, event, opts = {}) => {
    var _selected$key, _this$props$tryKeepOp;
    const isItem = item => List.isItemType(List.ListProps.Type.ITEM, item);
    const isCustomItem = item => List.isItemType(List.ListProps.Type.CUSTOM, item);
    const isSelectItemEvent = event && (event.type === 'select' || event.type === 'keydown');
    if (isSelectItemEvent) {
      event.preventDefault();
    }
    if (!isItem(selected) && !isCustomItem(selected) || selected.disabled || selected.isResetItem) {
      return;
    }
    const lastInteractedKey = (_selected$key = selected?.key) !== null && _selected$key !== void 0 ? _selected$key : null;
    const tryKeepOpen = (_this$props$tryKeepOp = this.props.tryKeepOpen) !== null && _this$props$tryKeepOp !== void 0 ? _this$props$tryKeepOp : opts.tryKeepOpen;
    if (!this.props.multiple) {
      var _selected$key2;
      if (!tryKeepOpen) {
        this._hidePopup(isSelectItemEvent);
      }
      this.setState({
        selected,
        lastInteractedKey: (_selected$key2 = selected?.key) !== null && _selected$key2 !== void 0 ? _selected$key2 : null
      }, () => {
        const newFilterValue = this.isInputMode() && !this.props.hideSelected ? getItemLabel(selected) : '';
        this.filterValue(newFilterValue);
        this.props.onFilter(newFilterValue);
        this.props.onSelect(selected, event);
        this.props.onChange(selected, event);
      });
    } else {
      if (!tryKeepOpen) {
        this._hidePopup(isSelectItemEvent);
      }
      if (selected.key === null || selected.key === undefined) {
        throw new Error('Multiple selection requires each item to have the "key" property');
      }
      this.setState(prevState => {
        const currentSelection = prevState.selected;
        let nextSelection;
        if (!prevState.multipleMap[selected.key]) {
          nextSelection = currentSelection.concat(selected);
        } else {
          nextSelection = currentSelection.filter(item => item.key !== selected.key);
        }
        const nextState = {
          filterValue: '',
          selected: nextSelection,
          lastInteractedKey: tryKeepOpen ? lastInteractedKey : null
        };
        if (typeof this.props.multiple === 'object' && this.props.multiple.limit && nextSelection.length === this.props.multiple.limit) {
          nextState.shownData = prevState.shownData.map(item => nextSelection.find(selectedItem => selectedItem.key === item.key) ? item : {
            ...item,
            disabled: true
          });
        }
        if (!prevState.multipleMap[selected.key]) {
          nextState.multipleMap = {
            ...prevState.multipleMap,
            [selected.key]: true
          };
        } else {
          const {
            [selected.key]: _,
            ...restMultipleMap
          } = prevState.multipleMap;
          nextState.multipleMap = restMultipleMap;
        }
        return {
          ...prevState,
          ...nextState
        };
      }, () => {
        if (this.state.multipleMap[selected.key]) {
          this.props.onSelect?.(selected, event);
        } else {
          this.props.onDeselect?.(selected);
        }
        this.props.onChange(this.state.selected, event);
        if (tryKeepOpen) {
          this._redrawPopup();
        }
      });
    }
  };
  _listSelectAllHandler = (isSelectAll = true) => {
    const isItem = item => List.isItemType(List.ListProps.Type.ITEM, item);
    const isCustomItem = item => List.isItemType(List.ListProps.Type.CUSTOM, item);
    this.setState(prevState => {
      const currentSelection = prevState.selected;
      let nextSelection;
      if (isSelectAll) {
        nextSelection = this.props.data.filter(item => (isItem(item) || isCustomItem(item)) && !item.disabled);
        nextSelection.filter(item => !this.props.selected.find(selectedItem => item.key === selectedItem.key)).forEach(item => {
          this.props.onSelect?.(item);
        });
      } else {
        nextSelection = [];
        currentSelection.forEach(item => {
          this.props.onDeselect?.(item);
        });
      }
      this.props.onChange(nextSelection, event);
      return {
        filterValue: '',
        selected: nextSelection,
        shownData: prevState.shownData.map(item => ({
          ...item,
          checkbox: isSelectAll
        })),
        multipleMap: isSelectAll ? buildMultipleMap(this.props.data.filter(item => !item.disabled)) : {}
      };
    }, this._redrawPopup);
  };
  _onCloseAttempt = (event, isEsc) => {
    if (this.isInputMode()) {
      if (!this.props.allowAny) {
        if (this.props.hideSelected || !this.state.selected || this.props.multiple) {
          this.clearFilter();
        } else if (this.state.selected && !Array.isArray(this.state.selected)) {
          this.filterValue(getItemLabel(this.state.selected));
        }
      }
    }
    const isTagRemoved = this.props.tags && event && event.target && event.target instanceof Element && event.target.matches('[data-test="ring-tag-remove"]');
    if (!isTagRemoved) {
      this._hidePopup(isEsc);
    }
  };
  clearFilter = e => {
    this._setFilter('', e);
  };
  clear = event => {
    if (event) {
      event.stopPropagation();
    }
    const empty = this.props.multiple ? [] : null;
    this.setState({
      selected: empty,
      lastInteractedKey: null,
      filterValue: ''
    }, () => {
      if (this.props.onChange) {
        this.props.onChange(empty, event);
      }
    });
    return false;
  };
  _selectionIsEmpty() {
    return Array.isArray(this.state.selected) && !this.state.selected.length || !this.state.selected;
  }
  _getLabel() {
    var _ref, _this$props$label;
    return (_ref = (_this$props$label = this.props.label) !== null && _this$props$label !== void 0 ? _this$props$label : this.props.selectedLabel) !== null && _ref !== void 0 ? _ref : 'Select an option';
  }
  _getPlaceholder() {
    if (this._selectionIsEmpty()) {
      var _this$props$label2;
      return (_this$props$label2 = this.props.label) !== null && _this$props$label2 !== void 0 ? _this$props$label2 : 'Select an option';
    }
    return this._getSelectedString();
  }
  _getSelectedString() {
    if (Array.isArray(this.state.selected)) {
      const labels = [];
      for (let i = 0; i < this.state.selected.length; i++) {
        labels.push(getItemLabel(this.state.selected[i]));
      }
      return labels.filter(Boolean).join(', ');
    }
    return this.state.selected !== null && this.state.selected !== undefined ? getItemLabel(this.state.selected) : null;
  }
  getHeight() {
    return this.props.height || (typeof this.context === 'function' ? this.context() : this.context);
  }
  _getIcons() {
    const {
      selected
    } = this.state;
    const {
      disabled,
      clear,
      hideArrow
    } = this.props;
    const icons = [];
    const height = this.getHeight();
    if (!Array.isArray(selected) && selected?.icon) {
      icons.push(/*#__PURE__*/jsx("button", {
        title: "Toggle options popup",
        type: "button",
        className: styles.selectedIcon,
        disabled: this.props.disabled,
        onClick: this._clickHandler,
        style: {
          backgroundImage: `url(${selected.icon})`
        }
      }, 'selected'));
    }
    if (clear && !disabled && !this._selectionIsEmpty()) {
      icons.push(/*#__PURE__*/jsx(Button, {
        title: "Clear selection",
        "data-test": "ring-clear-select",
        className: styles.clearIcon,
        disabled: this.props.disabled,
        onClick: this.clear,
        height: height,
        icon: closeIcon
      }, 'close'));
    }
    if (!hideArrow) {
      icons.push(/*#__PURE__*/jsx(Button, {
        title: "Toggle options popup",
        className: styles.chevron,
        iconClassName: styles.chevronIcon,
        icon: chevronDownIcon,
        disabled: this.props.disabled,
        height: height,
        onClick: this._clickHandler
      }, 'hide'));
    }
    return icons;
  }
  _getAvatar() {
    return !Array.isArray(this.state.selected) && (this.state.selected?.avatar || this.state.selected?.showGeneratedAvatar) && /*#__PURE__*/jsx(Avatar, {
      className: styles.avatar,
      url: this.state.selected.avatar,
      username: this.state.selected.username,
      size: Size$1.Size20
    });
  }
  filter;
  filterRef = el => {
    this.filter = el;
  };
  composedFilterRef = createComposedRef();
  getShortcutsMap() {
    return {
      enter: this._onEnter,
      esc: this._onEsc,
      up: this._inputShortcutHandler,
      down: this._inputShortcutHandler,
      right: noop,
      left: noop,
      'shift+up': noop,
      'shift+down': noop,
      space: noop
    };
  }
  // eslint-disable-next-line complexity
  renderSelect(activeItemId) {
    var _ref2, _this$props$label3, _this$props$buttonCla;
    const dataTest = this.props['data-test'];
    const {
      selectedLabel
    } = this.props;
    const {
      shortcutsEnabled
    } = this.state;
    const classes = classNames(styles.select, 'ring-js-shortcuts', this.props.className, styles[`height${this.getHeight()}`], {
      [styles[`size${this.props.size}`]]: this.props.type !== Type.INLINE,
      [styles.disabled]: this.props.disabled
    });
    let style;
    let iconsNode;
    if (this.props.type === Type.INPUT || this.props.type === Type.BUTTON) {
      const icons = this._getIcons();
      style = getStyle(icons.length);
      iconsNode = /*#__PURE__*/jsx("div", {
        className: styles.icons,
        children: icons
      });
    }
    const ariaProps = {
      role: 'combobox',
      'aria-expanded': this.state.showPopup,
      'aria-controls': this.listId,
      'aria-activedescendant': this.state.showPopup ? activeItemId : undefined,
      'aria-label': (_ref2 = (_this$props$label3 = this.props.label) !== null && _this$props$label3 !== void 0 ? _this$props$label3 : this._getPlaceholder()) !== null && _ref2 !== void 0 ? _ref2 : undefined
    };
    switch (this.props.type) {
      case Type.INPUT_WITHOUT_CONTROLS:
      case Type.INPUT:
        return /*#__PURE__*/jsxs(Fragment$1, {
          children: [/*#__PURE__*/jsxs("div", {
            ref: this.nodeRef,
            className: classNames(classes, styles.inputMode),
            "data-test": joinDataTestAttributes('ring-select', dataTest),
            role: "presentation" // has interactive elements inside
            ,
            onMouseDown: this.mouseDownHandler,
            onMouseUp: this.mouseUpHandler,
            children: [shortcutsEnabled && /*#__PURE__*/jsx(Shortcuts, {
              map: this.getShortcutsMap(),
              scope: this.shortcutsScope
            }), /*#__PURE__*/jsx(Input, {
              ...ariaProps,
              height: this.props.height,
              autoComplete: "off",
              id: this.props.id,
              onClick: this._clickHandler,
              inputRef: this.composedFilterRef(this.filterRef, this.props.filterRef),
              disabled: this.props.disabled,
              value: this.state.filterValue,
              borderless: this.props.type === Type.INPUT_WITHOUT_CONTROLS,
              style: style,
              size: Size.FULL,
              onChange: this._filterChangeHandler,
              onFocus: this._focusHandler,
              onBlur: this._blurHandler
              // Input with error style without description
              ,
              error: this.props.error ? '' : null,
              label: this.props.type === Type.INPUT ? this._getLabel() : null,
              placeholder: this.props.inputPlaceholder,
              onKeyDown: this.props.onKeyDown,
              "data-test": "ring-select__focus",
              enableShortcuts: shortcutsEnabled ? Object.keys({
                ...this.getShortcutsMap(),
                ...this._popup?.list?.shortcutsMap
              }) : undefined,
              icon: this.props.filterIcon,
              afterInput: iconsNode
            }), this._renderPopup()]
          }), this.props.error && /*#__PURE__*/jsx("div", {
            className: classNames(inputStyles.errorText, inputStyles[`size${this.props.size}`]),
            children: this.props.error
          })]
        });
      case Type.BUTTON:
        return /*#__PURE__*/jsxs("div", {
          ref: this.nodeRef,
          className: classNames(classes, styles.buttonMode),
          "data-test": joinDataTestAttributes('ring-select', dataTest),
          children: [selectedLabel && /*#__PURE__*/jsx(ControlLabel, {
            type: this.props.labelType,
            disabled: this.props.disabled,
            htmlFor: this.props.id,
            children: selectedLabel
          }), shortcutsEnabled && /*#__PURE__*/jsx(Shortcuts, {
            map: this.getShortcutsMap(),
            scope: this.shortcutsScope
          }), /*#__PURE__*/jsxs("div", {
            className: styles.buttonContainer,
            children: [/*#__PURE__*/jsxs(Button, {
              ...ariaProps,
              height: this.props.height,
              id: this.props.id,
              onClick: this._clickHandler,
              className: classNames(this.props.buttonClassName, styles.buttonValue, {
                [styles.buttonValueOpen]: this.state.showPopup,
                [styles.buttonValueEmpty]: this._selectionIsEmpty()
              }),
              disabled: this.props.disabled,
              style: style,
              "data-test": "ring-select__button ring-select__focus",
              children: [this._getAvatar(), this._getPlaceholder()]
            }), iconsNode]
          }), this._renderPopup()]
        });
      case Type.INLINE:
        return /*#__PURE__*/jsxs("div", {
          className: classes,
          ref: this.nodeRef,
          "data-test": joinDataTestAttributes('ring-select', dataTest),
          children: [shortcutsEnabled && /*#__PURE__*/jsx(Shortcuts, {
            map: this.getShortcutsMap(),
            scope: this.shortcutsScope
          }), /*#__PURE__*/jsx(Anchor, {
            ...ariaProps,
            className: (_this$props$buttonCla = this.props.buttonClassName) !== null && _this$props$buttonCla !== void 0 ? _this$props$buttonCla : undefined,
            id: this.props.id,
            onClick: this._clickHandler,
            "data-test": "ring-select__focus",
            disabled: this.props.disabled,
            active: this.state.showPopup,
            children: this._getPlaceholder()
          }), this._renderPopup()]
        });
      default:
        if (this.props.customAnchor) {
          var _this$props$buttonCla2;
          return /*#__PURE__*/jsxs(Fragment, {
            children: [shortcutsEnabled && /*#__PURE__*/jsx(Shortcuts, {
              map: this.getShortcutsMap(),
              scope: this.shortcutsScope
            }), this.props.customAnchor({
              wrapperProps: {
                ref: this.nodeRef,
                'data-test': joinDataTestAttributes('ring-select', dataTest)
              },
              buttonProps: {
                ...ariaProps,
                id: this.props.id,
                onClick: this._clickHandler,
                disabled: this.props.disabled,
                children: this._getPlaceholder(),
                'data-test': 'ring-select__focus',
                className: (_this$props$buttonCla2 = this.props.buttonClassName) !== null && _this$props$buttonCla2 !== void 0 ? _this$props$buttonCla2 : undefined
              },
              popup: this._renderPopup()
            })]
          });
        }
        return /*#__PURE__*/jsx("span", {
          id: this.props.id,
          ref: this.nodeRef,
          "data-test": "ring-select",
          children: this._renderPopup()
        });
    }
  }
  render() {
    return /*#__PURE__*/jsx(ActiveItemContext.Provider, {
      children: /*#__PURE__*/jsx(ActiveItemContext.ValueContext.Consumer, {
        children: activeItemId => this.renderSelect(activeItemId)
      })
    });
  }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const RerenderableSelect = rerenderHOC(Select);

export { RerenderableSelect, Type, Select as default };
