import { encodeURL, joinBaseURLAndPath } from '../global/url.js';

/**
 * @name HTTP
 */
const TOKEN_TYPE = 'Bearer';
const defaultFetchConfig = {
  headers: {
    'Content-Type': 'application/json',
    Accept: 'application/json'
  },
  credentials: 'same-origin'
};
class HTTPError extends Error {
  data;
  status;
  constructor(response, data = {}) {
    super(`${response.status} ${response.statusText || ''}`);
    this.data = data;
    this.status = response.status;
  }
}
const CODE = {
  UNAUTHORIZED: 401
};
function isRawBody(params) {
  return params.sendRawBody === true;
}
class HTTP {
  baseUrl = null;
  _requestsMeta = new WeakMap();
  fetchConfig;
  requestToken;
  shouldRefreshToken;
  forceTokenUpdate;
  constructor(auth, baseUrl, fetchConfig = {}) {
    if (auth) {
      this.setAuth(auth);
    }
    this.setBaseUrl(baseUrl);
    const {
      headers,
      ...defaultConfig
    } = defaultFetchConfig;
    this.fetchConfig = {
      ...defaultConfig,
      ...fetchConfig,
      headers: {
        ...headers,
        ...fetchConfig.headers
      }
    };
  }
  setAuth = auth => {
    this.requestToken = () => auth.requestToken();
    this.shouldRefreshToken = auth.constructor.shouldRefreshToken;
    this.forceTokenUpdate = () => auth.forceTokenUpdate();
  };
  setBaseUrl = baseUrl => {
    this.baseUrl = baseUrl;
  };
  _fetch(...args) {
    return fetch(...args);
  }
  _makeRequestUrl(url, queryObject) {
    const urlWithQuery = encodeURL(url, queryObject);
    return joinBaseURLAndPath(this.baseUrl, urlWithQuery);
  }
  _performRequest(url, token, params = {}) {
    const {
      headers,
      body,
      query = {},
      sendRawBody,
      ...fetchConfig
    } = params;
    const combinedHeaders = {
      ...this.fetchConfig.headers,
      ...(token ? {
        Authorization: `${TOKEN_TYPE} ${token}`
      } : {}),
      ...headers
    };
    Object.entries(combinedHeaders).forEach(([key, header]) => {
      if (header === null || header === undefined) {
        Reflect.deleteProperty(combinedHeaders, key);
      }
    });
    let bodyToSend;
    if (isRawBody(params)) {
      bodyToSend = params.body;
    } else {
      bodyToSend = params.body === null || params.body === undefined || params.body === '' ? params.body : JSON.stringify(body);
    }
    return this._fetch(this._makeRequestUrl(url, query), {
      ...this.fetchConfig,
      headers: combinedHeaders,
      ...fetchConfig,
      body: bodyToSend
    });
  }
  _storeRequestMeta(parsedResponse, rawResponse) {
    const {
      headers,
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    } = rawResponse;
    this._requestsMeta.set(parsedResponse, {
      headers,
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    });
  }
  async _processResponse(response) {
    const contentType = response.headers.get('content-type');
    const isJson = contentType && contentType.indexOf('application/json') !== -1;
    if (!response.ok) {
      let resJson;
      try {
        resJson = await (isJson ? response.json() : response.text());
      } catch (err) {
        // noop
      }
      throw new HTTPError(response, resJson);
    }
    try {
      const parsedResponse = await (isJson ? response.json() : {
        data: await response.text()
      });
      this._storeRequestMeta(parsedResponse, response);
      return parsedResponse;
    } catch (err) {
      return response;
    }
  }
  fetch = async (url, params = {}) => {
    const {
      body,
      query = {},
      ...fetchConfig
    } = params;
    const response = await this._fetch(this._makeRequestUrl(url, query), {
      ...fetchConfig,
      headers: fetchConfig.headers,
      body: body !== null && body !== undefined && body !== '' ? JSON.stringify(body) : body
    });
    return this._processResponse(response);
  };
  async authorizedFetch(...args) {
    const response = await this._performRequest(...args);
    return this._processResponse(response);
  }
  request = async (url, params) => {
    let token = await this.requestToken?.();
    let response = await this._performRequest(url, token, params);
    try {
      // Wait for result to catch an HTTP error
      return await this._processResponse(response);
    } catch (error) {
      if (!(error instanceof HTTPError)) {
        throw error;
      }
      const shouldRefreshToken = typeof error.data.error === 'string' ? this.shouldRefreshToken?.(error.data.error) : false;
      if (shouldRefreshToken) {
        token = await this.forceTokenUpdate?.();
        response = await this._performRequest(url, token, params);
        return this._processResponse(response);
      }
      throw error;
    }
  };
  getMetaForResponse = response => this._requestsMeta.get(response);
  get = (url, params) => this.request(url, {
    ...params,
    method: 'GET'
  });
  post = (url, params) => this.request(url, {
    ...params,
    method: 'POST'
  });
  delete = (url, params) => this.request(url, {
    ...params,
    method: 'DELETE'
  });
  put = (url, params) => this.request(url, {
    ...params,
    method: 'PUT'
  });
  /**
   * Usage: const {promise, abort} = http.abortify(http.get<{id: string}>)('http://test.com');
   * @param method
   */
  abortify = method => (...[url, params]) => {
    const ctrl = new AbortController();
    if (params && !('signal' in params)) {
      params.signal = ctrl.signal;
    }
    return {
      promise: method.call(this, url, params),
      abort: () => ctrl.abort()
    };
  };
}

export { CODE, HTTPError, HTTP as default, defaultFetchConfig };
