import { c } from 'react-compiler-runtime';
import { forwardRef, useRef, useImperativeHandle, useEffect } from 'react';
import { isNodeInVisiblePartOfPage } from '../global/dom.js';
import { jsx, jsxs } from 'react/jsx-runtime';

var styles = {"trapButton":"ring-tab-trap-trapButton"};

const FOCUSABLE_ELEMENTS = 'input, button, select, textarea, a[href], *[tabindex]:not([data-trap-button]):not([data-scrollable-container])';
// eslint-disable-next-line no-shadow
const TabTrap = /*#__PURE__*/forwardRef(function TabTrap(t0, ref) {
  const $ = c(36);
  if ($[0] !== "0332e0ee653a0153e98c2004e643614e720cfc900b162b7629295f63077cddf5") {
    for (let $i = 0; $i < 36; $i += 1) {
      $[$i] = Symbol.for("react.memo_cache_sentinel");
    }
    $[0] = "0332e0ee653a0153e98c2004e643614e720cfc900b162b7629295f63077cddf5";
  }
  let children;
  let restProps;
  let t1;
  let t2;
  let t3;
  let t4;
  if ($[1] !== t0) {
    ({
      children,
      trapDisabled: t1,
      autoFocusFirst: t2,
      focusBackOnClose: t3,
      focusBackOnExit: t4,
      ...restProps
    } = t0);
    $[1] = t0;
    $[2] = children;
    $[3] = restProps;
    $[4] = t1;
    $[5] = t2;
    $[6] = t3;
    $[7] = t4;
  } else {
    children = $[2];
    restProps = $[3];
    t1 = $[4];
    t2 = $[5];
    t3 = $[6];
    t4 = $[7];
  }
  const trapDisabled = t1 === undefined ? false : t1;
  const autoFocusFirst = t2 === undefined ? true : t2;
  const focusBackOnClose = t3 === undefined ? true : t3;
  const focusBackOnExit = t4 === undefined ? false : t4;
  const nodeRef = useRef(null);
  const trapButtonNodeRef = useRef(null);
  const previousFocusedNodeRef = useRef(null);
  const trapWithoutFocusRef = useRef(false);
  const mountedRef = useRef(false);
  if (previousFocusedNodeRef.current === null) {
    previousFocusedNodeRef.current = document.activeElement;
  }
  let t5;
  let t6;
  if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = () => ({
      node: nodeRef.current
    });
    t6 = [];
    $[8] = t5;
    $[9] = t6;
  } else {
    t5 = $[8];
    t6 = $[9];
  }
  useImperativeHandle(ref, t5, t6);
  let t7;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = function restoreFocus() {
      const previousFocusedNode = previousFocusedNodeRef.current;
      if (previousFocusedNode instanceof HTMLElement && previousFocusedNode.focus && isNodeInVisiblePartOfPage(previousFocusedNode)) {
        if (!mountedRef.current) {
          previousFocusedNode.focus({
            preventScroll: true
          });
        }
      }
    };
    $[10] = t7;
  } else {
    t7 = $[10];
  }
  const restoreFocus = t7;
  let t8;
  if ($[11] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = function focusElement(t9) {
      const first = t9 === undefined ? true : t9;
      const node = nodeRef.current;
      if (!node) {
        return;
      }
      const tabables = [...node.querySelectorAll(FOCUSABLE_ELEMENTS)].filter(_temp);
      const toBeFocused = first ? tabables[0] : tabables[tabables.length - 1];
      if (toBeFocused) {
        toBeFocused.focus();
      }
    };
    $[11] = t8;
  } else {
    t8 = $[11];
  }
  const focusElement = t8;
  let t9;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = () => focusElement(true);
    $[12] = t9;
  } else {
    t9 = $[12];
  }
  const focusFirst = t9;
  let t10;
  if ($[13] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = () => focusElement(false);
    $[13] = t10;
  } else {
    t10 = $[13];
  }
  const focusLast = t10;
  let t11;
  let t12;
  if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = () => {
      mountedRef.current = true;
      return () => {
        mountedRef.current = false;
      };
    };
    t12 = [];
    $[14] = t11;
    $[15] = t12;
  } else {
    t11 = $[14];
    t12 = $[15];
  }
  useEffect(t11, t12);
  let t13;
  let t14;
  if ($[16] !== autoFocusFirst || $[17] !== focusBackOnClose || $[18] !== trapDisabled) {
    t13 = () => {
      if (autoFocusFirst) {
        focusFirst();
      } else {
        if (!trapDisabled) {
          const previousFocusedElementIsInContainer = previousFocusedNodeRef.current && nodeRef.current?.contains(previousFocusedNodeRef.current);
          const currentlyFocusedElementIsInContainer = nodeRef.current?.contains(document.activeElement);
          if (!nodeRef.current || !previousFocusedElementIsInContainer && !currentlyFocusedElementIsInContainer) {
            trapWithoutFocusRef.current = true;
            trapButtonNodeRef.current?.focus();
          }
        }
      }
      return () => {
        if (focusBackOnClose) {
          restoreFocus();
        }
      };
    };
    t14 = [autoFocusFirst, trapDisabled, focusBackOnClose, focusFirst];
    $[16] = autoFocusFirst;
    $[17] = focusBackOnClose;
    $[18] = trapDisabled;
    $[19] = t13;
    $[20] = t14;
  } else {
    t13 = $[19];
    t14 = $[20];
  }
  useEffect(t13, t14);
  let t15;
  if ($[21] !== focusBackOnExit) {
    t15 = function focusLastIfEnabled(event) {
      if (trapWithoutFocusRef.current) {
        return;
      }
      if (focusBackOnExit) {
        const prevFocused = event.nativeEvent.relatedTarget;
        if (prevFocused && nodeRef.current && prevFocused instanceof Element && nodeRef.current.contains(prevFocused)) {
          restoreFocus();
        }
      } else {
        focusLast();
      }
    };
    $[21] = focusBackOnExit;
    $[22] = t15;
  } else {
    t15 = $[22];
  }
  const focusLastIfEnabled = t15;
  let t16;
  if ($[23] === Symbol.for("react.memo_cache_sentinel")) {
    t16 = function handleBlurIfWithoutFocus(event_0) {
      if (!trapWithoutFocusRef.current) {
        return;
      }
      trapWithoutFocusRef.current = false;
      const newFocused = event_0.nativeEvent.relatedTarget;
      if (!newFocused) {
        return;
      }
      if (newFocused instanceof Element && nodeRef.current?.contains(newFocused)) {
        return;
      }
      focusLast();
    };
    $[23] = t16;
  } else {
    t16 = $[23];
  }
  const handleBlurIfWithoutFocus = t16;
  if (trapDisabled) {
    let t17;
    if ($[24] !== children || $[25] !== restProps) {
      t17 = /*#__PURE__*/jsx("div", {
        ref: nodeRef,
        ...restProps,
        children: children
      });
      $[24] = children;
      $[25] = restProps;
      $[26] = t17;
    } else {
      t17 = $[26];
    }
    return t17;
  }
  let t17;
  if ($[27] !== focusLastIfEnabled) {
    t17 = /*#__PURE__*/jsx("div", {
      tabIndex: 0,
      ref: trapButtonNodeRef,
      className: styles.trapButton,
      onFocus: focusLastIfEnabled,
      onBlur: handleBlurIfWithoutFocus,
      "data-trap-button": true
    });
    $[27] = focusLastIfEnabled;
    $[28] = t17;
  } else {
    t17 = $[28];
  }
  const t18 = focusBackOnExit ? restoreFocus : focusFirst;
  let t19;
  if ($[29] !== t18) {
    t19 = /*#__PURE__*/jsx("div", {
      tabIndex: 0,
      onFocus: t18,
      "data-trap-button": true
    });
    $[29] = t18;
    $[30] = t19;
  } else {
    t19 = $[30];
  }
  let t20;
  if ($[31] !== children || $[32] !== restProps || $[33] !== t17 || $[34] !== t19) {
    t20 = /*#__PURE__*/jsxs("div", {
      ref: nodeRef,
      ...restProps,
      children: [t17, children, t19]
    });
    $[31] = children;
    $[32] = restProps;
    $[33] = t17;
    $[34] = t19;
    $[35] = t20;
  } else {
    t20 = $[35];
  }
  return t20;
});
function _temp(item) {
  return item.tabIndex >= 0;
}

export { FOCUSABLE_ELEMENTS, TabTrap as default };
