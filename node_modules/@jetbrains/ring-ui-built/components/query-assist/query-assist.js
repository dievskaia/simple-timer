import { Component } from 'react';
import debounce from 'just-debounce-it';
import classNames from 'classnames';
import { dequal } from 'dequal';
import searchIcon from '@jetbrains/icons/search';
import closeIcon from '@jetbrains/icons/close-12px';
import getUID from '../global/get-uid.js';
import joinDataTestAttributes from '../global/data-tests.js';
import { preventDefault, getRect } from '../global/dom.js';
import Caret from '../caret/caret.js';
import ContentEditable from '../contenteditable/contenteditable.js';
import PopupMenu from '../popup-menu/popup-menu.js';
import LoaderInline from '../loader-inline/loader-inline.js';
import Shortcuts from '../shortcuts/shortcuts.js';
import rerenderHOC from '../global/rerender-hoc.js';
import { Button } from '../button/button.js';
import Icon from '../icon/icon.js';
import { ControlsHeightContext } from '../global/controls-height.js';
import { S as Size, i as inputStyles } from '../_helpers/input.js';
import { I18nContext } from '../i18n/i18n-context.js';
import { Q as QueryAssistSuggestions, s as styles } from '../_helpers/query-assist-suggestions.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import { ControlsHeight } from '../global/configuration.js';
import 'react-compiler-runtime';
import 'react-dom/server';
import '../popup/popup.js';
import 'react-dom';
import '../global/schedule-raf.js';
import '../tab-trap/tab-trap.js';
import '../popup/position.js';
import '../popup/popup.consts.js';
import '../popup/popup.target.js';
import '../popup/position-css.js';
import '../_helpers/theme.js';
import '../list/list.js';
import 'react-virtualized/dist/es/List';
import 'react-virtualized/dist/es/AutoSizer';
import 'react-virtualized/dist/es/WindowScroller';
import 'react-virtualized/dist/es/CellMeasurer';
import 'util-deprecate';
import 'memoize-one';
import '../global/memoize.js';
import '../global/create-stateful-context.js';
import '../list/list-item.js';
import '../avatar/avatar.js';
import '../global/url.js';
import '../avatar/fallback-avatar.js';
import '../avatar/avatar-size.js';
import '../_helpers/avatar-info.js';
import '../checkbox/checkbox.js';
import '@jetbrains/icons/checkmark-12px';
import '@jetbrains/icons/remove-12px';
import '../global/compose-refs.js';
import '../control-help/control-help.js';
import '../link/link.js';
import '../link/clickable-link.js';
import '../_helpers/link.js';
import '../list/consts.js';
import '../list/list.classes.js';
import '../_helpers/list.js';
import '../icon/icon.constants.js';
import '../_helpers/icon-svg.js';
import '../list/list-custom.js';
import '../global/get-event-key.js';
import '../list/list-title.js';
import '../list/list-separator.js';
import '../list/list-hint.js';
import '../shortcuts/core.js';
import 'combokeys';
import '../global/sniffer.js';
import 'sniffr';
import '@jetbrains/icons/chevron-down';
import '@jetbrains/icons/chevron-12px-down';
import '../_helpers/button.classes.js';
import '../control-label/control-label.js';
import '../i18n/i18n.js';

const POPUP_COMPENSATION = PopupMenu.ListProps.Dimension.ITEM_PADDING + PopupMenu.PopupProps.Dimension.BORDER_WIDTH;
const ngModelStateField = 'query';
function noop() {}
function cleanText(text) {
  return text.replace(/([\n\r])+/g, ' ');
}
/**
 * @name Query Assist
 */
/**
 * ## Data source function

 Component class calls a data source function when user input happens and passes an object with fields \`caret\`, \`focus\` and \`query\` as the only argument.
 The function must return an object with the fields described below. The object can be optionally wrapped in a Promise.

 ### Return object fields

 \`caret\` and \`query\` should just return server values provided to data source function.
 These fields allow the Query Assist component to recognise and drop earlier responses from the server.

 + __caret__ (\`string=0\`) Caret from request
 + __query__ (\`string=''\`) Query from request
 + __styleRanges__ (\`Array<suggestion>=\`) Array of \`styleRange\` objects, used to highlight the request in the input field
 + __suggestions__ (\`Array<styleRange>\`) Array of \`suggestion\` objects to show.

 ### **styleRange** object fields

 start \`number\` Range start (in characters)
 length \`number\` Range length (in characters)
 style \`string\` Style of the range. Possible values: \`text\`, \`field_value\`, \`field_name\`, \`operator\`

 ### **suggestion** object fields

 + __prefix__ \`string=\` Suggestion option prefix
 + __option__ \`string\` Suggestion option
 + __suffix__ \`string=\` Suggestion option suffix
 + __description__ \`string=\` Suggestion option description. Is not visible when a group is set
 + __matchingStart__ \`number\` (required when matchingEnd is set) Start of the highlighted part of an option in the suggestions list (in characters)
 + __matchingEnd__ \`number\` (required when matchingEnd is set) End of the highlighted part of an option in the suggestions list (in characters)
 + __caret__ \`number\` Caret position after option completion (in characters)
 + __completionStart__ \`number\` Where to start insertion (or replacement, when completing with the \`Tab\` key) of the completion option (in characters)
 + __completionEnd__ \`number\` Where to end insertion of the completion option (in characters)
 + __group__ \`string=\` Group title. Options with the same title are grouped under it
 + __icon__ \`string=\` Icon URI, Data URI is possible
 */
class QueryAssist extends Component {
  static defaultProps = {
    onApply: noop,
    onChange: noop,
    onApplySuggestion: noop,
    onClear: noop,
    onFocusChange: noop,
    size: Size.L
  };
  static getDerivedStateFromProps({
    query
  }, {
    prevQuery
  }) {
    const nextState = {
      prevQuery: query
    };
    if (typeof query === 'string' && query !== prevQuery) {
      nextState.query = query;
      nextState.placeholderEnabled = !query;
    }
    return nextState;
  }
  constructor(props) {
    super(props);
    const query = props.query || '';
    this.immediateState = {
      query,
      caret: typeof props.caret === 'number' && Number.isFinite(props.caret) ? props.caret : query.length,
      focus: Boolean(props.autoOpen || props.focus)
    };
  }
  state = {
    dirty: !this.props.query,
    query: this.props.query,
    placeholderEnabled: !this.props.query,
    shortcuts: !!this.props.focus,
    suggestions: [],
    showPopup: false
  };
  componentDidMount() {
    const query = this.props.query || '';
    this.immediateState = {
      query,
      caret: typeof this.props.caret === 'number' && Number.isFinite(this.props.caret) ? this.props.caret : query.length,
      focus: Boolean(this.props.autoOpen || this.props.focus)
    };
    this.setupRequestHandler(this.props.delay);
    if (this.props.autoOpen === 'force' || this.props.autoOpen && query.length > 0) {
      this.requestHandler().catch(noop);
    } else {
      this.requestStyleRanges().catch(noop);
    }
    this.setCaretPosition();
    this._pushHistory(this.state);
  }
  shouldComponentUpdate(props, state) {
    return state.query !== this.state.query || state.dirty !== this.state.dirty || state.loading !== this.state.loading || state.showPopup !== this.state.showPopup || state.suggestions !== this.state.suggestions || state.styleRanges !== this.state.styleRanges || state.placeholderEnabled !== this.state.placeholderEnabled || state.shortcuts !== this.state.shortcuts || props.placeholder !== this.props.placeholder || props.disabled !== this.props.disabled || props.clear !== this.props.clear || props.focus !== this.props.focus || props.actions !== this.props.actions || props.loader !== this.props.loader || props.glass !== this.props.glass || props.className !== this.props.className || props.delay !== this.props.delay;
  }
  componentDidUpdate(prevProps) {
    const {
      caret,
      delay,
      query
    } = this.props;
    const queryChanged = query !== prevProps.query;
    this.updateFocus(prevProps);
    this.setupRequestHandler(delay);
    const shouldSetCaret = typeof caret === 'number' && caret !== prevProps.caret;
    if (shouldSetCaret) {
      this.immediateState.prevCaret = prevProps.caret;
      this.immediateState.caret = caret;
    }
    if (typeof query === 'string' && queryChanged && query !== this.immediateState.query) {
      this.immediateState.query = query;
      if (query && (this.props.autoOpen === 'force' || prevProps.autoOpen && query.length > 0)) {
        this.requestData?.();
      } else if (query) {
        this.requestStyleRanges();
      }
    }
  }
  static ngModelStateField = ngModelStateField;
  immediateState;
  requestData;
  ngModelStateField = ngModelStateField;
  // An array of {query: string; caret: number}[]
  historyStack = [];
  mouseIsDownOnPopup;
  handleFocusChange = e => {
    // otherwise it's blur and false
    const focus = e.type === 'focus';
    this.immediateState.focus = focus;
    if (!focus) {
      this.blurInput();
      // Close popup on blur by keyboard (mostly shift+tab)
      if (!this.mouseIsDownOnPopup) {
        this.closePopup();
      }
    } else {
      this.setCaretPosition();
    }
    if (!this.mouseIsDownOnPopup) {
      this.props.onFocusChange({
        focus
      });
    }
    if (this.state.shortcuts !== focus) {
      this.setState({
        shortcuts: focus
      });
    }
  };
  node;
  nodeRef = node => {
    this.node = node;
  };
  updateFocus({
    focus,
    caret
  }) {
    const isCaretChanged = caret !== this.props.caret;
    const isFocusChanged = focus !== this.props.focus;
    if (isFocusChanged || isCaretChanged) {
      const focusValue = isFocusChanged ? this.props.focus : true;
      this.setFocus(focusValue);
    }
  }
  // eslint-disable-next-line complexity
  setCaretPosition = (params = {}) => {
    const queryLength = this.immediateState.query ? this.immediateState.query.length : 0;
    const newCaretPosition = this.immediateState.caret < queryLength ? this.immediateState.caret : queryLength;
    if (params.fromContentEditable) {
      this.immediateState.selection = this.immediateState.selection ? this.immediateState.selection : this.state.query && this.state.query.length || null;
    }
    if (this.immediateState.focus && !this.props.disabled) {
      if (typeof this.immediateState.selection === 'number' && Number.isInteger(this.immediateState.selection) && this.immediateState.selection > -1) {
        // Set to end of field value if newCaretPosition is inappropriate
        this.caret?.setPosition(newCaretPosition >= 0 ? newCaretPosition : -1);
        this.scrollInput();
      } else if (this.immediateState.selection && typeof this.immediateState.selection === 'object' && this.immediateState.selection.startOffset !== undefined) {
        this.caret?.setPosition(this.immediateState.selection);
      } else if (this.immediateState.selection === undefined || params.forceSetCaret) {
        this.caret?.setPosition(-1);
      }
    }
  };
  scrollInput() {
    const caretOffset = this.caret?.getOffset();
    if (this.input?.clientWidth !== this.input?.scrollWidth && caretOffset && this.input?.clientWidth !== undefined && caretOffset > this.input?.clientWidth) {
      this.input.scrollLeft += caretOffset;
    }
  }
  getQuery() {
    var _this$input$textConte;
    return (_this$input$textConte = this.input?.textContent?.replace(/\s/g, ' ')) !== null && _this$input$textConte !== void 0 ? _this$input$textConte : '';
  }
  isRenderingGlassOrLoader() {
    const renderLoader = this.props.loader !== false && this.state.loading;
    return this.props.glass || renderLoader;
  }
  togglePlaceholder = () => {
    const query = this.getQuery();
    const currentQueryIsEmpty = this.immediateState.query === '';
    const newQueryIsEmpty = query === '';
    if (newQueryIsEmpty !== currentQueryIsEmpty) {
      this.setState({
        placeholderEnabled: newQueryIsEmpty
      });
    }
  };
  isComposing;
  handleInput = e => {
    var _currentCaret$positio;
    this.togglePlaceholder();
    const currentCaret = this.caret?.getPosition();
    const props = {
      dirty: true,
      query: this.getQuery(),
      caret: typeof currentCaret === 'number' ? currentCaret : (_currentCaret$positio = currentCaret?.position) !== null && _currentCaret$positio !== void 0 ? _currentCaret$positio : 0,
      focus: true
    };
    if (this.immediateState.query === props.query && !this.isComposing) {
      this.handleCaretMove(e);
      return;
    }
    if (this.isComposing) {
      return;
    }
    this.immediateState = props;
    if (this.state.query) {
      var _this$state$styleRang;
      let i = 0;
      while (this.state.query[i] === this.immediateState.query[i] && i < this.state.query.length - 1) {
        i++;
      }
      const diff = this.immediateState.query.length - this.state.query.length;
      const originalIndex = this.immediateState.caret - diff;
      const ranges = [...((_this$state$styleRang = this.state.styleRanges) !== null && _this$state$styleRang !== void 0 ? _this$state$styleRang : [])];
      const range = ranges.find(r => originalIndex >= r.start && originalIndex <= r.start + r.length);
      if (range) {
        range.length += diff;
      }
      ranges.filter(r => r.start > originalIndex).forEach(r => {
        r.start += diff;
      });
    }
    this.props.onChange(props);
    if (this.props.autoOpen === 'force' || props.query.length > 0) {
      this.requestData?.();
    }
  };
  // It's necessary to prevent new element creation before any other hooks
  handleEnter = e => {
    if (e.key === 'Enter') {
      preventDefault(e);
    }
  };
  handleTab = e => {
    const list = this._popup && this._popup.list;
    const suggestion = list && (list.getSelected() || list.getFirst());
    if (suggestion && this.state.showPopup) {
      preventDefault(e);
      if (this.getQuery() !== this.immediateState.suggestionsQuery) {
        return false;
      }
      return this.handleComplete(suggestion, true);
    }
    if (this.state.loading) {
      preventDefault(e);
      return false;
    }
    return true;
  };
  setState = (state, resolve) => {
    super.setState(state, () => {
      this._pushHistory(state);
      resolve?.();
    });
  };
  _pushHistory(state) {
    const queryIsSet = 'query' in state;
    const queryIsSame = this.historyStack[0]?.query === state.query;
    if (queryIsSet && !queryIsSame) {
      var _this$caret$getPositi;
      this.historyStack.unshift({
        query: state.query,
        caret: (_this$caret$getPositi = this.caret?.getPosition({
          avoidFocus: true
        })) !== null && _this$caret$getPositi !== void 0 ? _this$caret$getPositi : -1
      });
    }
  }
  undo = e => {
    const previous = this.historyStack.splice(0, 2)[1];
    if (!previous) {
      return;
    }
    this.setState({
      query: previous.query
    }, () => {
      this.caret?.setPosition(previous.caret);
      this.handleInput(e);
    });
  };
  handlePaste = e => {
    const INSERT_COMMAND = 'insertText';
    if (e.clipboardData && document.queryCommandSupported(INSERT_COMMAND)) {
      preventDefault(e);
      const text = cleanText(e.clipboardData.getData('text/plain'));
      document.execCommand(INSERT_COMMAND, false, text);
      this.handleInput(e);
    }
  };
  handleCaretMove = e => {
    var _currentCaret$positio2;
    if (this.isComposing) {
      return;
    }
    const currentCaret = this.caret?.getPosition();
    const caret = typeof currentCaret === 'number' ? currentCaret : (_currentCaret$positio2 = currentCaret?.position) !== null && _currentCaret$positio2 !== void 0 ? _currentCaret$positio2 : 0;
    const popupHidden = !this.state.showPopup && e.type === 'click';
    if (!this.props.disabled && (caret !== this.immediateState.caret || popupHidden)) {
      this.immediateState.prevCaret = this.immediateState.caret;
      this.immediateState.caret = caret;
      this.scrollInput();
      if (this.immediateState.query.length > 0) {
        this.requestData?.();
      }
    }
    if (this.props.autoOpen !== 'force' && this.immediateState.query.length < 1) {
      this.setState({
        showPopup: false
      });
    }
  };
  handleStyleRangesResponse = ({
    suggestions,
    ...restProps
  }) => this.handleResponse(restProps);
  handleResponse = ({
    query = '',
    caret = 0,
    styleRanges,
    suggestions = []
  }, afterCompletion = false) => new Promise((resolve, reject) => {
    if (query === this.getQuery() && (caret === this.immediateState.caret || this.immediateState.caret === undefined)) {
      // Do not setState on unmounted component
      if (!this.node) {
        return;
      }
      const state = {
        dirty: this.immediateState.dirty,
        loading: false,
        placeholderEnabled: !query,
        query,
        suggestions,
        showPopup: !!suggestions.length && (this.props.autoOpen === 'force' || !afterCompletion)
      };
      this.immediateState.suggestionsQuery = query;
      // Do not update deep equal styleRanges to simplify shouldComponentUpdate check
      if (!dequal(this.state.styleRanges, styleRanges)) {
        state.styleRanges = styleRanges;
      }
      this.immediateState.selection = this.caret?.getPosition({
        avoidFocus: true
      });
      this.setState(state, resolve);
    } else {
      reject(new Error('Current and response queries mismatch'));
    }
  });
  handleApply = () => {
    this.closePopup();
    this.immediateState.dirty = false;
    // Only set dirty to false when query is saved already
    if (this.immediateState.query === this.state.query) {
      this.setState({
        dirty: false
      });
    }
    return this.props.onApply(this.immediateState);
  };
  handleComplete = (data, replace) => {
    var _suggestion$caret, _suggestion$caret2;
    if (!data || !data.data) {
      this.handleApply();
      return;
    }
    const query = this.getQuery();
    const currentCaret = this.immediateState.caret;
    const suggestion = data.data;
    const prefix = suggestion.prefix || '';
    const suffix = suggestion.suffix || '';
    const state = {
      prevCaret: currentCaret,
      caret: (_suggestion$caret = suggestion.caret) !== null && _suggestion$caret !== void 0 ? _suggestion$caret : 0,
      selection: (_suggestion$caret2 = suggestion.caret) !== null && _suggestion$caret2 !== void 0 ? _suggestion$caret2 : 0,
      query: query.substr(0, suggestion.completionStart) + prefix + suggestion.option + suffix
    };
    if (typeof replace === 'boolean' && replace) {
      var _suggestion$completio;
      state.query += this.immediateState.query.substr((_suggestion$completio = suggestion.completionEnd) !== null && _suggestion$completio !== void 0 ? _suggestion$completio : 0);
    } else {
      state.query += this.immediateState.query.substr(this.immediateState.caret);
    }
    this.props.onChange(state);
    this.props.onApplySuggestion(data.data, state);
    const focusState = {
      focus: true
    };
    this.props.onFocusChange(focusState);
    if (state.query !== this.immediateState.query) {
      this.setState({
        placeholderEnabled: !state.query,
        query: state.query
      });
    }
    this.immediateState = Object.assign(state, focusState);
    if (this.immediateState.caret !== currentCaret) {
      this.setCaretPosition();
    }
    this.closePopup();
    this.requestData?.(true);
  };
  requestStyleRanges = () => {
    const {
      query,
      caret
    } = this.immediateState;
    if (!query) {
      return Promise.reject(new Error('Query is empty'));
    }
    return this.sendRequest({
      query,
      caret,
      omitSuggestions: true
    }).then(this.handleStyleRangesResponse).catch(noop);
  };
  requestHandler = (afterCompletion = false) => {
    if (this.props.disabled) {
      return Promise.reject(new Error('QueryAssist(@jetbrains/ring-ui): null exception'));
    }
    const {
      query,
      caret
    } = this.immediateState;
    return this.sendRequest({
      query,
      caret
    }).then(data => this.handleResponse(data, afterCompletion)).catch(noop);
  };
  sendRequest(params) {
    const value = this.props.dataSource(params);
    const dataPromise = Promise.resolve(value);
    const CLOSE_POPUP_TIMEOUT = 500;
    // Close popup after timeout between long requests
    const timeout = window.setTimeout(() => {
      if (this.node) {
        this.setState({
          loading: true
        });
      }
      if (params.query === this.immediateState.query) {
        this.closePopup();
      }
    }, CLOSE_POPUP_TIMEOUT);
    dataPromise.then(() => window.clearTimeout(timeout)).catch(() => {
      window.clearTimeout(timeout);
      this.setState({
        loading: false
      });
    });
    return dataPromise;
  }
  getPopupOffset(suggestions) {
    const ICON_SPACING = 12;
    const minOffset = this.isRenderingGlassOrLoader() ? ICON_SPACING : 0;
    if (!this.input) {
      return minOffset;
    }
    // First suggestion should be enough?
    const suggestion = suggestions && suggestions[0];
    // Check if suggestion begins not from the end
    const completionStart = suggestion && suggestion.completionStart !== suggestion.completionEnd && suggestion.completionStart;
    const inputChildren = this.input.firstChild instanceof Element && this.input.firstChild.children;
    const completionStartNode = inputChildren && typeof completionStart === 'number' && inputChildren[Math.min(completionStart, inputChildren.length - 1)];
    let offset = completionStartNode && getRect(completionStartNode).right - getRect(this.input).left;
    if (!offset) {
      var _this$caret$getOffset;
      const caret = (_this$caret$getOffset = this.caret?.getOffset()) !== null && _this$caret$getOffset !== void 0 ? _this$caret$getOffset : 0;
      // Do not compensate caret in the beginning of field
      if (caret === 0) {
        return minOffset;
      }
      offset = caret;
    }
    const result = offset - POPUP_COMPENSATION;
    return result < minOffset ? minOffset : result;
  }
  handleCtrlSpace = e => {
    preventDefault(e);
    if (!this.state.showPopup) {
      this.requestData?.();
    }
  };
  trackPopupMouseState = e => {
    this.mouseIsDownOnPopup = e.type === 'mousedown';
  };
  trackCompositionState = e => {
    this.isComposing = e.type !== 'compositionend';
  };
  closePopup = () => {
    if (this.node) {
      this.setState({
        showPopup: false
      });
    }
  };
  clearQuery = () => {
    const state = {
      dirty: false,
      caret: 0,
      query: '',
      focus: true
    };
    this.props.onChange(state);
    this.props.onClear();
    this.immediateState = state;
    this.setState({
      dirty: false,
      query: '',
      placeholderEnabled: true,
      loading: false
    });
  };
  blurInput() {
    this.immediateState.selection = null;
    if (!this.props.focus) {
      this.caret?.target.blur();
    }
  }
  /**
   * Optionally setup data request delay. For each component create a separate
   * instance of the delayed function. This may help reduce the load on the server
   * when the user quickly inputs data.
   */
  setupRequestHandler(delay) {
    const needDelay = typeof delay === 'number';
    const hasDelay = this.requestData !== this.requestHandler;
    if (!this.requestData || hasDelay !== needDelay) {
      if (needDelay) {
        this.requestData = debounce(this.requestHandler, delay);
      } else {
        this.requestData = this.requestHandler;
      }
    }
  }
  _renderSuggestion(suggestion) {
    const {
      ITEM
    } = PopupMenu.ListProps.Type;
    const {
      description,
      icon,
      group
    } = suggestion;
    const key = QueryAssistSuggestions.createKey(suggestion);
    const label = QueryAssistSuggestions.renderLabel(suggestion);
    return {
      key,
      icon,
      label,
      description,
      group,
      rgItemType: ITEM,
      data: suggestion
    };
  }
  renderSuggestions() {
    const {
      suggestions
    } = this.state;
    if (!suggestions || !suggestions.length) {
      return [];
    }
    return QueryAssistSuggestions.renderList(suggestions, this._renderSuggestion);
  }
  renderQuery() {
    const {
      dirty,
      styleRanges,
      query
    } = this.state;
    const classes = [];
    const LETTER_CLASS = 'letter';
    const LETTER_DEFAULT_CLASS = styles.letterDefault;
    if (styleRanges && styleRanges.length) {
      styleRanges.forEach((item, index) => {
        if (dirty && index === styleRanges.length - 1 && item.style === 'text') {
          return;
        }
        const styleName = `${LETTER_CLASS}-${item.style.replace('_', '-')}`;
        for (let i = item.start; i < item.start + item.length; i++) {
          classes[i] = styles[styleName];
        }
      });
    }
    return query && Array.from(query).map((letter, index, letters) => {
      const className = classNames(styles.letter, classes[index] || LETTER_DEFAULT_CLASS);
      const dataTest = letters.length - 1 === index ? 'ring-query-assist-last-letter' : null;
      // \u00a0 === &nbsp;
      return /*#__PURE__*/jsx("span", {
        className: className,
        "data-test": dataTest,
        children: letter === ' ' ? '\u00a0' : letter
      }, index + letter);
    });
  }
  setFocus(focus) {
    this.setState({
      shortcuts: !!focus
    });
    const isComponentFocused = Boolean(this.immediateState.focus);
    if (focus === false && isComponentFocused) {
      this.immediateState.focus = focus;
      this.blurInput();
    } else if (focus === true && !isComponentFocused) {
      this.immediateState.focus = focus;
      this.setCaretPosition({
        forceSetCaret: true
      });
    }
  }
  input;
  caret;
  inputRef = node => {
    if (!node) {
      return;
    }
    this.input = node;
    this.caret = new Caret(this.input);
  };
  _popup;
  popupRef = node => {
    this._popup = node;
  };
  placeholder;
  placeholderRef = node => {
    this.placeholder = node;
  };
  glass;
  glassRef = node => {
    this.glass = node;
  };
  loader;
  loaderRef = node => {
    this.loader = node;
  };
  clear;
  clearRef = node => {
    this.clear = node;
  };
  shortcutsScope = getUID('ring-query-assist-');
  shortcutsMap = {
    del: noop,
    enter: () => this.handleComplete(),
    'command+enter': () => this.handleComplete(),
    'ctrl+enter': () => this.handleComplete(),
    'ctrl+space': this.handleCtrlSpace,
    tab: this.handleTab,
    'meta+z': this.undo,
    right: noop,
    left: noop,
    space: noop,
    home: noop,
    end: noop
  };
  listShortcutsMap = {
    home: noop,
    end: noop
  };
  renderActions() {
    const actions = [...(this.props.actions || [])];
    const renderClear = this.props.clear && !!this.state.query;
    if (renderClear) {
      actions.push(/*#__PURE__*/jsx(I18nContext.Consumer, {
        children: ({
          translate
        }) => {
          var _this$props$translati;
          return /*#__PURE__*/jsx(Button, {
            icon: closeIcon,
            className: classNames(styles.clear, this.props.clearIconClassName),
            title: (_this$props$translati = this.props.translations?.clearTitle) !== null && _this$props$translati !== void 0 ? _this$props$translati : translate('clearTitle'),
            ref: this.clearRef,
            onClick: this.clearQuery,
            "data-test": "query-assist-clear-icon"
          });
        }
      }, 'clearAction'));
    }
    return actions;
  }
  render() {
    const {
      glass,
      'data-test': dataTest,
      className,
      useCustomItemRender,
      huge,
      size,
      translations
    } = this.props;
    const renderPlaceholder = !!this.props.placeholder && this.state.placeholderEnabled;
    const renderLoader = this.props.loader !== false && this.state.loading;
    const renderGlass = glass && !renderLoader;
    const actions = this.renderActions();
    const containerClasses = classNames(className, inputStyles[`size${huge ? Size.FULL : size}`], {
      [styles.queryAssist]: true,
      [styles.withIcon]: renderGlass && !huge || renderLoader,
      [styles.huge]: huge,
      [styles.queryAssistDisabled]: this.props.disabled
    });
    const inputClasses = classNames(this.props.inputClassName, {
      [`${styles.input} ring-js-shortcuts`]: true,
      [styles.inputGap]: actions.length || this.isRenderingGlassOrLoader() && !glass,
      [styles.inputGap2]: actions.length === 2,
      // TODO: replace with flex-box layout
      [styles.inputRevertOrder]: !glass || huge
    });
    const placeholderStyles = classNames({
      [styles.placeholder]: true,
      [styles.hugePlaceholder]: huge,
      [styles.withoutGlass]: !glass || !renderLoader && huge
    });
    return /*#__PURE__*/jsx(ControlsHeightContext.Provider, {
      value: ControlsHeight.M,
      children: /*#__PURE__*/jsx(I18nContext.Consumer, {
        children: ({
          translate
        }) => {
          var _translations$searchT, _translations$searchT2, _translations$searchT3;
          return /*#__PURE__*/jsxs("div", {
            "data-test": joinDataTestAttributes('ring-query-assist', dataTest),
            className: containerClasses,
            role: "presentation",
            ref: this.nodeRef,
            children: [this.state.shortcuts && /*#__PURE__*/jsx(Shortcuts, {
              map: this.shortcutsMap,
              scope: this.shortcutsScope
            }), renderGlass && !huge && /*#__PURE__*/jsx(Icon, {
              glyph: searchIcon,
              className: classNames(styles.icon, this.props.searchButtonClassName),
              title: (_translations$searchT = translations?.searchTitle) !== null && _translations$searchT !== void 0 ? _translations$searchT : translate('searchTitle'),
              ref: this.glassRef,
              "data-test": "query-assist-search-icon"
            }), renderLoader && /*#__PURE__*/jsx("div", {
              className: classNames(styles.icon, styles.loader, {
                [styles.loaderOnTheRight]: !glass && !huge,
                [styles.loaderActive]: renderLoader
              }),
              ref: this.loaderRef,
              children: /*#__PURE__*/jsx(LoaderInline, {})
            }), /*#__PURE__*/jsx(ContentEditable, {
              "aria-label": (_translations$searchT2 = translations?.searchTitle) !== null && _translations$searchT2 !== void 0 ? _translations$searchT2 : translate('searchTitle'),
              className: inputClasses,
              "data-test": "ring-query-assist-input",
              inputRef: this.inputRef,
              disabled: this.props.disabled,
              onComponentUpdate: () => this.setCaretPosition({
                fromContentEditable: true
              }),
              onBlur: this.handleFocusChange,
              onClick: this.handleCaretMove,
              onCompositionStart: this.trackCompositionState,
              onCompositionEnd: this.trackCompositionState,
              onFocus: this.handleFocusChange,
              onInput: this.handleInput // To support IE use the same method
              ,
              onKeyUp: this.handleInput // to handle input and key up
              ,
              onKeyDown: this.handleEnter,
              onPaste: this.handlePaste,
              spellCheck: "false",
              children: this.state.query && /*#__PURE__*/jsx("span", {
                children: this.renderQuery()
              })
            }), renderPlaceholder && /*#__PURE__*/jsx("button", {
              type: "button",
              className: placeholderStyles,
              ref: this.placeholderRef,
              onClick: this.handleCaretMove,
              "data-test": "query-assist-placeholder",
              disabled: this.props.disabled,
              tabIndex: -1,
              children: this.props.placeholder
            }), actions.length ? /*#__PURE__*/jsx("div", {
              "data-test": "ring-query-assist-actions",
              className: styles.actions,
              children: actions
            }) : null, /*#__PURE__*/jsx(PopupMenu, {
              hidden: !this.state.showPopup,
              onCloseAttempt: this.closePopup,
              ref: this.popupRef,
              anchorElement: this.node,
              keepMounted: true,
              attached: true,
              className: this.props.popupClassName,
              directions: [PopupMenu.PopupProps.Directions.BOTTOM_RIGHT],
              data: useCustomItemRender ? this.state.suggestions : this.renderSuggestions(),
              "data-test": "ring-query-assist-popup",
              hint: this.props.hint,
              shortcutsMap: this.listShortcutsMap,
              hintOnSelection: this.props.hintOnSelection,
              left: this.getPopupOffset(this.state.suggestions),
              maxHeight: PopupMenu.PopupProps.MaxHeight.SCREEN,
              onMouseDown: this.trackPopupMouseState,
              onMouseUp: this.trackPopupMouseState,
              onSelect: item => this.handleComplete(item)
            }), glass && huge && /*#__PURE__*/jsx("div", {
              className: styles.rightSearchButton,
              "data-test": "query-assist-search-button",
              children: /*#__PURE__*/jsx(Icon, {
                glyph: searchIcon,
                className: classNames(styles.rightSearchIcon, this.props.searchButtonClassName),
                title: (_translations$searchT3 = translations?.searchTitle) !== null && _translations$searchT3 !== void 0 ? _translations$searchT3 : translate('searchTitle'),
                onClick: this.handleApply,
                ref: this.glassRef,
                "data-test": "query-assist-search-icon"
              })
            })]
          });
        }
      })
    });
  }
}
const RerenderableQueryAssist = rerenderHOC(QueryAssist);

export { RerenderableQueryAssist, QueryAssist as default };
