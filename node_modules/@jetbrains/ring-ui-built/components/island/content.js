import { c } from 'react-compiler-runtime';
import { forwardRef, Component } from 'react';
import classNames from 'classnames';
import createResizeDetector from 'element-resize-detector';
import scheduleRAF from '../global/schedule-raf.js';
import { ScrollHandlerContext } from './adaptive-island-hoc.js';
import { s as styles } from '../_helpers/island.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import '../global/linear-function.js';

const scheduleScrollAction = scheduleRAF();
const noop = () => {};
const END_DISTANCE = 16;
class Content extends Component {
  static defaultProps = {
    fade: true,
    bottomBorder: false,
    onScroll: noop,
    onScrollToBottom: noop
  };
  state = {
    scrolledToTop: true,
    scrolledToBottom: false
  };
  componentWillUnmount() {
    this.scrollableNode = null;
    if (!this.wrapperNode) {
      return;
    }
    this.resizeDetector.removeAllListeners(this.wrapperNode);
  }
  resizeDetector = createResizeDetector({
    strategy: 'scroll'
  });
  wrapperNode;
  setWrapper = node => {
    if (!node) {
      return;
    }
    this.wrapperNode = node;
    this.resizeDetector.listenTo(node, this.calculateScrollPosition);
  };
  calculateScrollPosition = () => scheduleScrollAction(() => {
    const {
      scrollableNode
    } = this;
    if (!scrollableNode) {
      return;
    }
    this.props.onScroll(scrollableNode);
    const {
      scrollTop,
      scrollHeight,
      offsetHeight
    } = scrollableNode;
    const scrolledToTop = scrollTop === 0;
    const scrolledToBottom = offsetHeight + scrollTop >= scrollHeight - END_DISTANCE;
    if (scrolledToBottom) {
      this.props.onScrollToBottom?.();
    }
    this.setState({
      scrolledToTop,
      scrolledToBottom
    });
  });
  scrollableNode;
  setScrollableNodeAndCalculatePosition = node => {
    if (!node) {
      return;
    }
    this.scrollableNode = node;
    this.calculateScrollPosition();
  };
  render() {
    const {
      children,
      className,
      bottomBorder,
      scrollableWrapperClassName,
      onScroll,
      onScrollToBottom,
      fade,
      tabIndex,
      ...restProps
    } = this.props;
    const {
      scrolledToTop,
      scrolledToBottom
    } = this.state;
    const classes = classNames(styles.content, className, {
      [styles.contentWithTopFade]: fade && !scrolledToTop,
      [styles.contentWithBottomFade]: fade && !scrolledToBottom,
      [styles.withTransparentBottomBorder]: bottomBorder,
      [styles.withBottomBorder]: bottomBorder && !scrolledToBottom
    });
    const scrollableWrapperClasses = classNames(styles.scrollableWrapper, scrollableWrapperClassName);
    return /*#__PURE__*/jsx("div", {
      ...restProps,
      "data-test": "ring-island-content",
      className: classes,
      children: /*#__PURE__*/jsxs("div", {
        tabIndex: tabIndex,
        className: scrollableWrapperClasses,
        ref: this.setScrollableNodeAndCalculatePosition,
        onScroll: fade ? this.calculateScrollPosition : noop,
        children: [fade && /*#__PURE__*/jsx("div", {
          ref: this.setWrapper,
          children: children
        }), !fade && children]
      })
    });
  }
}
const ContentWrapper = /*#__PURE__*/forwardRef((props, ref) => {
  const $ = c(4);
  if ($[0] !== "c32a71969444a48a67d8737ca30be3eaf2fe1249949706470667058a052ec377") {
    for (let $i = 0; $i < 4; $i += 1) {
      $[$i] = Symbol.for("react.memo_cache_sentinel");
    }
    $[0] = "c32a71969444a48a67d8737ca30be3eaf2fe1249949706470667058a052ec377";
  }
  let t0;
  if ($[1] !== props || $[2] !== ref) {
    t0 = /*#__PURE__*/jsx(ScrollHandlerContext.Consumer, {
      children: onScroll => {
        const addProps = onScroll ? {
          onScroll,
          bottomBorder: true
        } : {};
        return /*#__PURE__*/jsx(Content, {
          ...props,
          ...addProps,
          ref: ref
        });
      }
    });
    $[1] = props;
    $[2] = ref;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
});
ContentWrapper.displayName = 'ContentWrapper';

export { ContentWrapper as default };
