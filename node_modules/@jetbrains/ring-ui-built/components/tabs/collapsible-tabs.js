import { c } from 'react-compiler-runtime';
import { memo, useState, useRef, useEffect } from 'react';
import classNames from 'classnames';
import fastdom from 'fastdom';
import { MoreButton, FakeMoreButton } from './collapsible-more.js';
import getTabTitles from './collapsible-tab.js';
import { s as styles } from '../_helpers/tab-link.js';
import { jsxs, jsx } from 'react/jsx-runtime';
import '../popup/popup.consts.js';
import '../popup-menu/popup-menu.js';
import '../popup/popup.js';
import 'react-dom';
import '../global/get-uid.js';
import '../global/schedule-raf.js';
import '../global/dom.js';
import '../shortcuts/shortcuts.js';
import '../shortcuts/core.js';
import 'combokeys';
import '../global/sniffer.js';
import 'sniffr';
import '../global/data-tests.js';
import '../tab-trap/tab-trap.js';
import '../global/configuration.js';
import '../popup/position.js';
import '../popup/popup.target.js';
import '../popup/position-css.js';
import '../_helpers/theme.js';
import '../list/list.js';
import 'react-virtualized/dist/es/List';
import 'react-virtualized/dist/es/AutoSizer';
import 'react-virtualized/dist/es/WindowScroller';
import 'react-virtualized/dist/es/CellMeasurer';
import 'util-deprecate';
import 'memoize-one';
import '../global/memoize.js';
import '../global/create-stateful-context.js';
import '../list/list-item.js';
import '../avatar/avatar.js';
import '../global/url.js';
import '../avatar/fallback-avatar.js';
import '../avatar/avatar-size.js';
import '../_helpers/avatar-info.js';
import '../checkbox/checkbox.js';
import '@jetbrains/icons/checkmark-12px';
import '@jetbrains/icons/remove-12px';
import '../icon/icon.js';
import '../icon/icon.constants.js';
import '../_helpers/icon-svg.js';
import '../global/compose-refs.js';
import '../control-help/control-help.js';
import '../link/link.js';
import '../link/clickable-link.js';
import '../_helpers/link.js';
import '../list/consts.js';
import '../list/list.classes.js';
import '../_helpers/list.js';
import '../list/list-custom.js';
import '../global/get-event-key.js';
import '../list/list-title.js';
import '../list/list-separator.js';
import '../list/list-hint.js';
import '../dropdown/dropdown.js';
import '../global/typescript-utils.js';
import '../_helpers/anchor.js';
import '../button/button.js';
import '@jetbrains/icons/chevron-down';
import '@jetbrains/icons/chevron-12px-down';
import '../global/controls-height.js';
import '../_helpers/button.classes.js';
import './custom-item.js';

const DEFAULT_DEBOUNCE_INTERVAL = 100;
const MEASURE_TOLERANCE = 0.5;
const CollapsibleTabs = t0 => {
  const $ = c(92);
  if ($[0] !== "70efbf9102ae6e4ef4eaf532e2761386fcd6421dbdab25489e6ec60adf5616c6") {
    for (let $i = 0; $i < 92; $i += 1) {
      $[$i] = Symbol.for("react.memo_cache_sentinel");
    }
    $[0] = "70efbf9102ae6e4ef4eaf532e2761386fcd6421dbdab25489e6ec60adf5616c6";
  }
  const {
    children,
    selected,
    onSelect,
    onLastVisibleIndexChange,
    moreClassName,
    moreActiveClassName,
    morePopupClassName,
    morePopupBeforeEnd,
    morePopupItemClassName,
    initialVisibleItems
  } = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      tabs: [],
      more: undefined
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const [sizes, setSizes] = useState(t1);
  const [lastVisibleIndex, setLastVisibleIndex] = useState(null);
  let t2;
  if ($[2] !== lastVisibleIndex || $[3] !== sizes) {
    t2 = {
      sizes,
      lastVisibleIndex
    };
    $[2] = lastVisibleIndex;
    $[3] = sizes;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const elements = t2;
  let t3;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      visible: [],
      hidden: []
    };
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const [preparedElements, setPreparedElements] = useState(t3);
  const measureRef = useRef(null);
  let t4;
  if ($[6] !== children || $[7] !== selected) {
    var _children$filter$find;
    t4 = (_children$filter$find = children.filter(_temp).findIndex(tab_0 => tab_0.props.id === selected)) !== null && _children$filter$find !== void 0 ? _children$filter$find : null;
    $[6] = children;
    $[7] = selected;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  const selectedIndex = t4;
  let t5;
  let visibleElements;
  if ($[9] !== children || $[10] !== initialVisibleItems || $[11] !== onSelect || $[12] !== preparedElements.hidden || $[13] !== preparedElements.ready || $[14] !== preparedElements.visible || $[15] !== selected) {
    let items;
    if (preparedElements.ready) {
      items = preparedElements.visible;
    } else {
      items = initialVisibleItems ? children.filter(_temp2).slice(0, initialVisibleItems) : [];
    }
    visibleElements = getTabTitles({
      items,
      selected,
      onSelect
    });
    bb0: {
      if (preparedElements.ready) {
        t5 = preparedElements.hidden;
        break bb0;
      }
      if (initialVisibleItems) {
        t5 = children.filter(item_0 => !visibleElements.some(visibleItem => visibleItem.props.child === item_0));
        break bb0;
      }
      let t6;
      if ($[18] === Symbol.for("react.memo_cache_sentinel")) {
        t6 = [];
        $[18] = t6;
      } else {
        t6 = $[18];
      }
      t5 = t6;
    }
    $[9] = children;
    $[10] = initialVisibleItems;
    $[11] = onSelect;
    $[12] = preparedElements.hidden;
    $[13] = preparedElements.ready;
    $[14] = preparedElements.visible;
    $[15] = selected;
    $[16] = t5;
    $[17] = visibleElements;
  } else {
    t5 = $[16];
    visibleElements = $[17];
  }
  const hiddenElements = t5;
  let t6;
  if ($[19] !== children || $[20] !== elements.lastVisibleIndex || $[21] !== elements.sizes || $[22] !== onLastVisibleIndexChange || $[23] !== selectedIndex) {
    t6 = entry => {
      const containerWidth = entry.contentRect.width;
      const {
        tabs: tabsSizes,
        more: t7
      } = elements.sizes;
      const more = t7 === undefined ? 0 : t7;
      const renderMore = children.some(_temp3);
      const tabsToRender = [];
      let filledWidth = renderMore ? more !== null && more !== void 0 ? more : 0 : 0;
      for (let i = 0; i < tabsSizes.length; i++) {
        if (filledWidth + tabsSizes[i] < containerWidth + MEASURE_TOLERANCE) {
          filledWidth = filledWidth + tabsSizes[i];
          tabsToRender.push(tabsSizes[i]);
        } else {
          break;
        }
      }
      if (tabsToRender.length < tabsSizes.length && !renderMore) {
        for (let i_0 = tabsToRender.length - 1; i_0 >= 0; i_0--) {
          if (filledWidth + more < containerWidth + MEASURE_TOLERANCE) {
            filledWidth = filledWidth + more;
            break;
          } else {
            filledWidth = filledWidth - tabsToRender[i_0];
            tabsToRender.pop();
          }
        }
      }
      if (selectedIndex > tabsToRender.length - 1) {
        const selectedWidth = tabsSizes[selectedIndex];
        for (let i_1 = tabsToRender.length - 1; i_1 >= 0; i_1--) {
          if (filledWidth + selectedWidth < containerWidth + MEASURE_TOLERANCE) {
            break;
          } else {
            filledWidth = filledWidth - tabsToRender[i_1];
            tabsToRender.pop();
          }
        }
      }
      const newLastVisibleIndex = tabsToRender.length - 1;
      if (elements.lastVisibleIndex !== newLastVisibleIndex) {
        setLastVisibleIndex(newLastVisibleIndex);
        onLastVisibleIndexChange?.(newLastVisibleIndex);
      }
    };
    $[19] = children;
    $[20] = elements.lastVisibleIndex;
    $[21] = elements.sizes;
    $[22] = onLastVisibleIndexChange;
    $[23] = selectedIndex;
    $[24] = t6;
  } else {
    t6 = $[24];
  }
  const adjustTabs = t6;
  let t7;
  if ($[25] !== children || $[26] !== elements.lastVisibleIndex || $[27] !== preparedElements.hidden || $[28] !== preparedElements.ready || $[29] !== preparedElements.visible || $[30] !== selected || $[31] !== selectedIndex) {
    t7 = () => {
      const timeout = setTimeout(() => {
        var _elements$lastVisible2;
        const res = children.reduce((accumulator, tab_2) => {
          var _elements$lastVisible;
          if (tab_2.props.alwaysHidden !== true && accumulator.visible.length - 1 < ((_elements$lastVisible = elements.lastVisibleIndex) !== null && _elements$lastVisible !== void 0 ? _elements$lastVisible : 0)) {
            accumulator.visible.push(tab_2);
          } else {
            accumulator.hidden.push(tab_2);
          }
          return accumulator;
        }, {
          visible: [],
          hidden: [],
          ready: elements.lastVisibleIndex !== null
        });
        if (selectedIndex > ((_elements$lastVisible2 = elements.lastVisibleIndex) !== null && _elements$lastVisible2 !== void 0 ? _elements$lastVisible2 : 0)) {
          const selectedItem = children.find(tab_3 => !tab_3.props.alwaysHidden && tab_3.props.id === selected);
          if (selectedItem !== null && selectedItem !== undefined) {
            res.visible.push(selectedItem);
          }
        }
        const allVisibleTheSame = res.visible.length === preparedElements.visible.length && res.visible.every((item_1, index) => item_1 === preparedElements.visible[index]);
        const allHiddenTheSame = res.hidden.length === preparedElements.hidden.length && res.hidden.every((item_2, index_0) => item_2 === preparedElements.hidden[index_0]);
        if (!allVisibleTheSame || !allHiddenTheSame || preparedElements.ready !== res.ready) {
          fastdom.mutate(() => setPreparedElements(res));
        }
      }, DEFAULT_DEBOUNCE_INTERVAL);
      return () => {
        clearTimeout(timeout);
      };
    };
    $[25] = children;
    $[26] = elements.lastVisibleIndex;
    $[27] = preparedElements.hidden;
    $[28] = preparedElements.ready;
    $[29] = preparedElements.visible;
    $[30] = selected;
    $[31] = selectedIndex;
    $[32] = t7;
  } else {
    t7 = $[32];
  }
  let t8;
  if ($[33] !== children || $[34] !== elements.lastVisibleIndex || $[35] !== preparedElements || $[36] !== selected || $[37] !== selectedIndex) {
    t8 = [children, elements.lastVisibleIndex, preparedElements, selected, selectedIndex];
    $[33] = children;
    $[34] = elements.lastVisibleIndex;
    $[35] = preparedElements;
    $[36] = selected;
    $[37] = selectedIndex;
    $[38] = t8;
  } else {
    t8 = $[38];
  }
  useEffect(t7, t8);
  let t9;
  if ($[39] !== children) {
    const childItems = children.filter(_temp4);
    t9 = getTabTitles({
      items: childItems,
      tabIndex: -1
    });
    $[39] = children;
    $[40] = t9;
  } else {
    t9 = $[40];
  }
  const childrenToMeasure = t9;
  let t10;
  if ($[41] !== elements.sizes.more || $[42] !== elements.sizes.tabs) {
    t10 = () => {
      if (measureRef.current === null) {
        return;
      }
      const measureTask = fastdom.measure(() => {
        var _container$children, _moreButton$offsetWid;
        const container = measureRef.current;
        const descendants = [...((_container$children = container?.children) !== null && _container$children !== void 0 ? _container$children : [])];
        const moreButton = descendants.pop();
        let moreButtonWidth = (_moreButton$offsetWid = moreButton?.offsetWidth) !== null && _moreButton$offsetWid !== void 0 ? _moreButton$offsetWid : 0;
        const {
          marginLeft: t11,
          marginRight: t12
        } = moreButton ? getComputedStyle(moreButton) : {};
        const moreButtonMarginLeft = t11 === undefined ? "0" : t11;
        const moreButtonMarginRight = t12 === undefined ? "0" : t12;
        moreButtonWidth = moreButtonWidth + (+moreButtonMarginLeft.replace("px", "") + +moreButtonMarginRight.replace("px", ""));
        const tabsWidth = descendants.map(_temp5);
        const newSummaryWidth = tabsWidth.reduce(_temp6, 0);
        const oldSummaryWidth = elements.sizes.tabs.reduce(_temp7, 0);
        if (elements.sizes.more !== moreButtonWidth || newSummaryWidth !== oldSummaryWidth) {
          fastdom.mutate(() => setSizes({
            more: moreButtonWidth,
            tabs: tabsWidth
          }));
        }
      });
      return () => {
        fastdom.clear(measureTask);
      };
    };
    $[41] = elements.sizes.more;
    $[42] = elements.sizes.tabs;
    $[43] = t10;
  } else {
    t10 = $[43];
  }
  let t11;
  if ($[44] !== children || $[45] !== elements.sizes.more || $[46] !== elements.sizes.tabs) {
    t11 = [children, elements.sizes.more, elements.sizes.tabs];
    $[44] = children;
    $[45] = elements.sizes.more;
    $[46] = elements.sizes.tabs;
    $[47] = t11;
  } else {
    t11 = $[47];
  }
  useEffect(t10, t11);
  let t12;
  let t13;
  if ($[48] !== adjustTabs) {
    t12 = () => {
      if (measureRef.current === null) {
        return;
      }
      let measureTask_0 = _temp8;
      const resizeObserver = new ResizeObserver(entries => {
        entries.forEach(entry_0 => {
          fastdom.clear(measureTask_0);
          measureTask_0 = fastdom.mutate(() => adjustTabs(entry_0));
        });
      });
      resizeObserver.observe(measureRef.current);
      return () => {
        fastdom.clear(measureTask_0);
        resizeObserver.disconnect();
      };
    };
    t13 = [adjustTabs];
    $[48] = adjustTabs;
    $[49] = t12;
    $[50] = t13;
  } else {
    t12 = $[49];
    t13 = $[50];
  }
  useEffect(t12, t13);
  const isAdjusted = elements.lastVisibleIndex !== null && preparedElements.ready || initialVisibleItems;
  let t14;
  let t15;
  let t16;
  let t17;
  if ($[51] !== hiddenElements || $[52] !== isAdjusted || $[53] !== moreActiveClassName || $[54] !== moreClassName || $[55] !== morePopupBeforeEnd || $[56] !== morePopupClassName || $[57] !== morePopupItemClassName || $[58] !== onSelect || $[59] !== selected || $[60] !== visibleElements) {
    const className = classNames(styles.titles, styles.autoCollapse, isAdjusted && styles.adjusted);
    t16 = styles.autoCollapseContainer;
    let t18;
    if ($[65] !== hiddenElements || $[66] !== moreActiveClassName || $[67] !== moreClassName || $[68] !== morePopupBeforeEnd || $[69] !== morePopupClassName || $[70] !== morePopupItemClassName || $[71] !== onSelect || $[72] !== selected) {
      t18 = /*#__PURE__*/jsx(MoreButton, {
        moreClassName: moreClassName,
        moreActiveClassName: moreActiveClassName,
        morePopupClassName: morePopupClassName,
        morePopupBeforeEnd: morePopupBeforeEnd,
        morePopupItemClassName: morePopupItemClassName,
        items: hiddenElements,
        selected: selected,
        onSelect: onSelect
      });
      $[65] = hiddenElements;
      $[66] = moreActiveClassName;
      $[67] = moreClassName;
      $[68] = morePopupBeforeEnd;
      $[69] = morePopupClassName;
      $[70] = morePopupItemClassName;
      $[71] = onSelect;
      $[72] = selected;
      $[73] = t18;
    } else {
      t18 = $[73];
    }
    t17 = /*#__PURE__*/jsxs("div", {
      className: classNames(className, styles.rendered),
      children: [visibleElements, t18]
    });
    t14 = measureRef;
    t15 = classNames(className, styles.measure);
    $[51] = hiddenElements;
    $[52] = isAdjusted;
    $[53] = moreActiveClassName;
    $[54] = moreClassName;
    $[55] = morePopupBeforeEnd;
    $[56] = morePopupClassName;
    $[57] = morePopupItemClassName;
    $[58] = onSelect;
    $[59] = selected;
    $[60] = visibleElements;
    $[61] = t14;
    $[62] = t15;
    $[63] = t16;
    $[64] = t17;
  } else {
    t14 = $[61];
    t15 = $[62];
    t16 = $[63];
    t17 = $[64];
  }
  let t18;
  if ($[74] !== hiddenElements || $[75] !== selected) {
    let t19;
    if ($[77] !== selected) {
      t19 = item_3 => item_3.props.alwaysHidden && item_3.props.id === selected;
      $[77] = selected;
      $[78] = t19;
    } else {
      t19 = $[78];
    }
    t18 = hiddenElements.some(t19);
    $[74] = hiddenElements;
    $[75] = selected;
    $[76] = t18;
  } else {
    t18 = $[76];
  }
  let t19;
  if ($[79] !== moreActiveClassName || $[80] !== moreClassName || $[81] !== t18) {
    t19 = /*#__PURE__*/jsx(FakeMoreButton, {
      hasActiveChildren: t18,
      moreClassName: moreClassName,
      moreActiveClassName: moreActiveClassName
    });
    $[79] = moreActiveClassName;
    $[80] = moreClassName;
    $[81] = t18;
    $[82] = t19;
  } else {
    t19 = $[82];
  }
  let t20;
  if ($[83] !== childrenToMeasure || $[84] !== t14 || $[85] !== t15 || $[86] !== t19) {
    t20 = /*#__PURE__*/jsxs("div", {
      ref: t14,
      className: t15,
      children: [childrenToMeasure, t19]
    });
    $[83] = childrenToMeasure;
    $[84] = t14;
    $[85] = t15;
    $[86] = t19;
    $[87] = t20;
  } else {
    t20 = $[87];
  }
  let t21;
  if ($[88] !== t16 || $[89] !== t17 || $[90] !== t20) {
    t21 = /*#__PURE__*/jsxs("div", {
      className: t16,
      children: [t17, t20]
    });
    $[88] = t16;
    $[89] = t17;
    $[90] = t20;
    $[91] = t21;
  } else {
    t21 = $[91];
  }
  return t21;
};
var CollapsibleTabs$1 = /*#__PURE__*/memo(CollapsibleTabs);
function _temp(tab) {
  return tab.props.alwaysHidden !== true;
}
function _temp2(item) {
  return item.props.alwaysHidden !== true;
}
function _temp3(tab_1) {
  return tab_1.props.alwaysHidden;
}
function _temp4(tab_4) {
  return tab_4.props.alwaysHidden !== true;
}
function _temp5(node) {
  const {
    marginLeft,
    marginRight
  } = getComputedStyle(node);
  const width = node.getBoundingClientRect().width;
  return width + +marginLeft.replace("px", "") + +marginRight.replace("px", "");
}
function _temp6(acc, curr) {
  return acc + curr;
}
function _temp7(acc_0, curr_0) {
  return acc_0 + curr_0;
}
function _temp8() {}

export { CollapsibleTabs, CollapsibleTabs$1 as default };
