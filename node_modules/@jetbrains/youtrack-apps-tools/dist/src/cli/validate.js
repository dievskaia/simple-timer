"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_SCHEMA_URL = void 0;
exports.validate = validate;
const tslib_1 = require("tslib");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const ajv_formats_1 = tslib_1.__importDefault(require("ajv-formats"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const promises_1 = tslib_1.__importDefault(require("node:fs/promises"));
const node_fs_1 = require("node:fs");
const exit_1 = require("../../lib/cli/exit");
const i18n_1 = require("../../lib/i18n/i18n");
const tmpdir_1 = require("../../lib/fs/tmpdir");
exports.DEFAULT_SCHEMA_URL = 'https://json.schemastore.org/youtrack-app.json';
const tmpSchemaPath = (0, tmpdir_1.tmpDir)('schema.json');
async function validate(config, appDir) {
    try {
        if (!appDir && !config.manifest) {
            (0, exit_1.exit)(new Error((0, i18n_1.i18n)('No directory or manifest file provided')));
        }
        if (config.manifest && !config.manifest.endsWith('.json')) {
            (0, exit_1.exit)(new Error((0, i18n_1.i18n)('Manifest file must be a JSON file')));
        }
        if (config.schema && !config.schema.endsWith('.json')) {
            (0, exit_1.exit)(new Error((0, i18n_1.i18n)('Schema file must be a JSON file')));
        }
        const ajv = new ajv_1.default({ strict: false });
        (0, ajv_formats_1.default)(ajv);
        const manifestFilePath = config.manifest ? config.manifest : node_path_1.default.join(appDir, 'manifest.json');
        const manifest = await parseFile(manifestFilePath);
        let schema;
        if (config.schema) {
            schema = isValidUrl(config.schema)
                ? await fetchSchema(config.schema)
                : await parseFile(config.schema);
        }
        else {
            schema = (0, node_fs_1.existsSync)(tmpSchemaPath)
                ? JSON.parse(await readSchemaFromTmp())
                : await fetchSchemaAndWriteToTmp(exports.DEFAULT_SCHEMA_URL);
        }
        const validateFn = ajv.compile(schema);
        const valid = validateFn(manifest);
        if (!valid) {
            throw new Error(validateFn.errors?.map(prepareError).join('\n'));
        }
        console.log((0, i18n_1.i18n)('Manifest is valid!'));
    }
    catch (error) {
        (0, exit_1.exit)(error);
    }
}
async function fetchSchema(url) {
    console.log((0, i18n_1.i18n)('Fetching schema...'));
    const res = await fetch(url);
    if (!res.ok)
        throw new Error(`Failed to fetch schema: ${res.statusText}`);
    return (await res.json());
}
async function parseFile(filePath) {
    return JSON.parse(await promises_1.default.readFile(filePath, { encoding: 'utf8' }));
}
function isValidUrl(string) {
    try {
        new URL(string);
        return true;
    }
    catch (_) {
        return false;
    }
}
function prepareError(error) {
    const ADDITIONAL_PROPERTIES_KEYWORD = 'additionalProperties';
    const additionalParams = error.keyword === ADDITIONAL_PROPERTIES_KEYWORD ? ` ${JSON.stringify(error.params.additionalProperty)}` : '';
    return `"${preparePath(error.instancePath) || 'manifest root'}" ${error.message}${additionalParams}`;
}
function preparePath(instancePath) {
    return instancePath.replace(/^\//, '').replace(/\//g, '.');
}
async function writeSchemaToTmp(schema) {
    await promises_1.default.writeFile(tmpSchemaPath, JSON.stringify(schema));
}
async function readSchemaFromTmp() {
    return await promises_1.default.readFile(tmpSchemaPath, { encoding: 'utf8' });
}
async function fetchSchemaAndWriteToTmp(url) {
    const schema = await fetchSchema(url);
    console.log((0, i18n_1.i18n)('Writing schema to tmp...'));
    await writeSchemaToTmp(schema);
    return schema;
}
